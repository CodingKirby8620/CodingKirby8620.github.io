<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WASM毕设 学习记录</title>
    <link href="/2025/03/06/WASM%E6%AF%95%E8%AE%BE/"/>
    <url>/2025/03/06/WASM%E6%AF%95%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<p>​本博客记录WASM毕设的学习过程及研读相关资料时产生的思路等杂项。由于前期在忙考研复试，进展会出奇地慢。</p><h4 id="任务总览"><a href="#任务总览" class="headerlink" title="任务总览"></a>任务总览</h4><p>​毕设任务原文如下：</p><blockquote><p>​WASM字节码是一种可以在网页上运行的栈式字节码，WASM-GC是WASM字节码的最新标准，能够全面支持内存垃圾收集器（Garbage Collector, GC）涉及的数据机构和指令。目前LLVM编译器可以生成不含GC指令的WASM字节码。毕设要求拓展目前LLVM代码生成器，使得其可以正确生成包含GC指令的WASM-GC字节码。</p></blockquote><p>​根据开题阶段的进一步调研可以把问题确定为：</p><ul><li>为llvm编写wasm-gc语言后端<ul><li>其中wasm-gc语言是wasm语言的一个扩展集</li><li>不要求实现所有功能，那太难了<ul><li>至少把跟类的封装相关的功能完成</li></ul></li></ul></li></ul><p>​对，总的任务就只有这一个，看上去很简单，但是如何继续进行拆分？</p><p>​当务之急有这么几个问题我希望搞清楚，针对这几个问题下手：</p><ul><li>wasm-gc与wasm的区别在哪里？我主要改写什么部分？</li><li>这个问题主要集中在llvm的后端，那llvm代码是如何生成的呢？<ul><li>llvm的运行流程是如何的？其中最重要的是中端到后端这一块究竟是如何运行的？</li><li>结合之前所探究到的语言差异，我如何将wasm-gc的部分功能移植到llvm上？</li></ul></li></ul><p>​综合所有问题来看，搞清楚llvm编译器的运行机理是最重要的环节，这个毕设实际是针对llvm编译器的全面分析，对这个大型系统的源码分析是必不可少的。这也将会是之后工作的一个重点。</p><h4 id="任务记录"><a href="#任务记录" class="headerlink" title="任务记录"></a>任务记录</h4><h5 id="探究wasm-gc语言和wasm语言的区别"><a href="#探究wasm-gc语言和wasm语言的区别" class="headerlink" title="探究wasm-gc语言和wasm语言的区别"></a>探究wasm-gc语言和wasm语言的区别</h5><h6 id="针对wasm-gc提案的概括"><a href="#针对wasm-gc提案的概括" class="headerlink" title="针对wasm-gc提案的概括"></a>针对wasm-gc提案的概括</h6><p>​在wasm官网可以查询到wasm-gc提案相关资料，此处资料显示此提案已经被标准化。</p><p>​针对gc仓库的MVP（最小可行产品）提案进行分析。</p><p>​针对MVP提案的分析如下：</p><ul><li>此MVP要求对应wasm语言版本已经实现<strong>部分前置提案</strong>：<ul><li>引用类型提案</li><li>类函数引用提案</li></ul></li><li>此MVP提案主要包括<strong>新类型</strong>：<ul><li>新的堆类型，引用类型</li><li>新的类型定义，类的上下文，类相等检验和子类映射</li></ul></li><li>此MVP提案也包括<strong>新指令</strong>：<ul><li>类型比较相等指令</li><li>聚合类型操控指令<ul><li>struct</li><li>array</li><li>i31</li></ul></li><li>外部类型转换指令</li><li>类型转换（cast）类指令</li><li>新的常量表达式指令<ul><li>跟新的类型相关</li></ul></li></ul></li></ul><p>​同时，官方官网文档给出核心实现的定义文档而没给出gc拓展实现的定义文档，于是先把拓展文档链接放在此处以便查阅。</p><blockquote><p>参考资料</p><p><a href="https://webassembly.github.io/gc/core/index.html">WebAssembly Specification — WebAssembly 2.0 + tail calls + function references + gc (Draft 2024-12-09)</a></p><p>这是带有gc实现的wasm文档</p></blockquote><h6 id="实现上的重大问题"><a href="#实现上的重大问题" class="headerlink" title="实现上的重大问题"></a>实现上的重大问题</h6><p>​针对原有测试代码所生成的代码进行分析，发现llvm现有wasm后端可能存在严重的不足</p><p>​关于此处代码生成的问题，现在需要做出的猜想是llvm现有后端<strong>仅仅实现了core部分而未完成任何额外提案</strong></p><p>​若是如此的话将会对wasm-gc子集的实现带来重大影响</p><p>TODO：当完成llvm后端分析时应返回补充此章内容，说明llvm的wasm后端指令集的缺陷</p><h5 id="对llvm编译器的工作流程分析"><a href="#对llvm编译器的工作流程分析" class="headerlink" title="对llvm编译器的工作流程分析"></a>对llvm编译器的工作流程分析</h5><p>TODO：待续</p>]]></content>
    
    
    <categories>
      
      <category>编译</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UE5 车辆运动 学习记录</title>
    <link href="/2025/02/21/UE5-%E8%BD%A6%E8%BE%86%E8%BF%90%E5%8A%A8-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/02/21/UE5-%E8%BD%A6%E8%BE%86%E8%BF%90%E5%8A%A8-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>​本博客记录如何在UE5中让车辆借助AI工具动起来的方法，以及其中涉及到的部分常用蓝图</p><blockquote><p>参考资料：</p><p><a href="https://blog.csdn.net/qq_34437757/article/details/133029202">UE5 ChaosVehicles载具研究 （连载一）_ue5载具转弯车轮卡顿-CSDN博客</a></p><p>这篇博客介绍了ChaosVehicle的常用节点及其功能，同时对摄像头的变换有启发</p><p><a href="https://www.bilibili.com/video/BV1BP4y1G78z/?spm_id_from=333.337.search-card.all.click&vd_source=e3bc0a74b003e86cc67e459d9355420a">虚幻引擎 - 车辆AI导航（非样条线）教程（全网首个非Character寻路教程）（已上传字幕文件）_哔哩哔哩_bilibili</a></p><p>实现上参考这个视频</p></blockquote><p>​这个流程建立在你有一个可以正常运动的车辆模型的基础之上，可以使用VehicleDemo的那个预设载具进行验证。</p><h4 id="流程总览"><a href="#流程总览" class="headerlink" title="流程总览"></a>流程总览</h4><p>​流程依次执行：</p><ul><li>设置行为树和黑板</li><li>编写行为树任务</li><li>构造AI控制器，并将其绑定到车辆上</li><li>然后构造路径，模拟运行</li></ul><p>​对于本应用场景，路径是不可定的，因此我们使用“寻路点”对车辆运行路径进行标识，合理密度的寻路点可以构成一个较好的路径，从而供车辆寻路，完成自动驾驶模拟。如果将所有路标数据生成都交给后端，这会是一个不错的方案</p><h4 id="流程分段"><a href="#流程分段" class="headerlink" title="流程分段"></a>流程分段</h4><h5 id="设置行为树和黑板"><a href="#设置行为树和黑板" class="headerlink" title="设置行为树和黑板"></a>设置行为树和黑板</h5><p>​我们以人的AI运动来做举例，人和车的区别仅在于行为树任务编写上</p><p>​我们需要两个变量：Index和Location，其中Index是服务于从预装载的Location数组中取出对应Location的，而这个Location将会被传递到对应的移动节点进行驱动。在这个架构中，驱动Pawn的责任由行为树承担</p><p><img src="/img/Posts/WeeklyReport/InitialSettingsHuman.png" alt="黑板和行为树的初始设置——人的情况"></p><p>​其中的BTTask_GetLocation是自己编写的蓝图任务节点，将在后文展示其逻辑</p><p>​很直白的流程：获取节点-&gt;移动到节点对应位置-&gt;等待（这个任务可以去掉）</p><h5 id="编写行为树任务——GetLocation"><a href="#编写行为树任务——GetLocation" class="headerlink" title="编写行为树任务——GetLocation"></a>编写行为树任务——GetLocation</h5><p>​第一个问题是如何获取Location，为了测试方便所以只编写了从预装载任务中获取所有坐标的逻辑。</p><p><img src="/img/Posts/WeeklyReport/OverallLogicGetLocation.png" alt="GetLocation总逻辑"></p><p>​这是总逻辑，核心函数是Get Target，至于使用PawnZ这个参数是由于人的中心点肯定是高于地面的，所以Location的Z肯定不等于人物的Z，我们使用人物的Z坐标来修正。</p><p><img src="/img/Posts/WeeklyReport/LogicGetTarget.png" alt="GetTarget逻辑"></p><p>​任务的总体逻辑长这样，其中注意Make Vector节点。PawnZ和Location的XY合成一个新的向量，这个向量带上了PawnZ的偏移，使得人的AI移动时能够正确处理位置关系；同时利用偏移量也能应对如上坡这种Z发生变化的情况。此处的Print String仅仅起到调试作用。至于别的都是语法细节</p><h5 id="构造AI控制器并进行绑定"><a href="#构造AI控制器并进行绑定" class="headerlink" title="构造AI控制器并进行绑定"></a>构造AI控制器并进行绑定</h5><p>​新建AIController类，在这个类中完成运行行为树和设置黑板初始值的预设</p><p>​将人物蓝图的对应设置同此新建的AIController类进行绑定即可</p><p>​语法很简单，仅给出AIController类作为参考，几乎全是语法细节</p><p>​然后就能正常驱动人的运行了</p><p><img src="/img/Posts/WeeklyReport/BindBT.png" alt="绑定行为树和设置初值"></p><h4 id="UE5的车辆运动控制"><a href="#UE5的车辆运动控制" class="headerlink" title="UE5的车辆运动控制"></a>UE5的车辆运动控制</h4><p>​车辆的AI设置和人的AI设置是大差不差的，但是最大的区别就在于人的运动逻辑不能套用到车的运动逻辑上，原生任务节点Move To因而不能套用到车辆上。由此，我们需要为车重新编写一套逻辑，这就是BTTask_VehicleMoveTo任务</p><h5 id="驱动原理"><a href="#驱动原理" class="headerlink" title="驱动原理"></a>驱动原理</h5><p>​车辆蓝图类是轮式载具Pawn的子类，这个子类驱动车辆运动的核心在于VehicleMoveComponent这个组件，通过对这个组件进行设置我们可以驱动车辆的运动。在优化后的蓝图中依次原理去掉Cast操作能极大限度的节约性能。</p><p>​所以在编写这个VehicleMoveTo任务时，只需要操控此Component就可以操控车辆的运动，事实上用于驱动车辆的常用节点正是以VehicleMoveComponent为输入的。</p><h5 id="编写任务"><a href="#编写任务" class="headerlink" title="编写任务"></a>编写任务</h5><p>​假定读着有一定任务树节点任务的基础知识。我们需要ReceiveExecuteAI事件节点和ReceiveTickAI事件节点来进行任务编写，核心是TickAI事件节点。</p><h6 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h6><p>​根据语法要求从黑板键中读取参数，保存组件。新的注册组件蓝图删去了Cast节点使得性能进一步提高。</p><p><img src="/img/Posts/WeeklyReport/VariableRegister.png" alt="注册组件"></p><h6 id="转向逻辑"><a href="#转向逻辑" class="headerlink" title="转向逻辑"></a>转向逻辑</h6><p>​在TickAI节点中编写车辆移动逻辑。这个节点在每一游戏Tick会被不断调用，驱动车辆运动并且检验车辆是否到达位置</p><p>​手动编写转向逻辑并不难，查找车辆位置-&gt;查找车辆对寻路点的角度-&gt;对减并且取Z轴旋转量-&gt;进行角度映射，输入转向节点。</p><p>​核心节点是Set Steering Input，这个节点接收[-1,1]的浮点数作为转向控制值，控制轮子在一定范围内转向（应该是[-90,90]吧）</p><p><img src="/img/Posts/WeeklyReport/Steering.png" alt="小车转向逻辑"></p><h6 id="油门逻辑"><a href="#油门逻辑" class="headerlink" title="油门逻辑"></a>油门逻辑</h6><p>​油门主要使用Set Throttle Input进行控制，接收[0,1]的油门强度进行控制</p><p>​同样存在刹车节点Set Brake Input和Set HandBrake Input，我不是很懂车所以不清楚刹车和手刹的区别，一般我是调用手刹节点的。借助这一对节点可以实现车辆速度控制。</p><p>​对于本Demo只使用简单的油门逻辑进行处理，实际这一块可以深挖很多，较好的模拟应该可以出车辆的变速行驶，这一块有待新的调研</p><p>​同时必须说明油门的强度，在模拟中这一块需要进行严格限制。油门过高会导致车辆容易飘出寻路路线（虽然车辆会有一定自己矫正的能力）</p><p><img src="/img/Posts/WeeklyReport/Throttle.png" alt="image-20250221184200052"></p><h6 id="误差判断"><a href="#误差判断" class="headerlink" title="误差判断"></a>误差判断</h6><p>​车辆模型的位点存在更大的Z偏差，而且在实际测试时车辆实际到达的位置可能会和实际寻路位置存在一定偏差（有可能不会完全准确），所以引入DeltaXY和DeltaZ变量。DeltaZ单列是因为车辆的Z偏差因为模型的原因可能会来的比XY偏差更大，这一变量个人觉得宜单独设置。</p><p>​TickAI会轮询最后的误差判断逻辑，当小车的位置在预设误差之内时会使任务成功，从而载入下一个寻路点。</p><p><img src="/img/Posts/WeeklyReport/CheckPosition.png" alt="检测位置相对误差"></p><p>​最后按照人AI的设置将剩余设置设置好，同时为DeltaXY和DeltaZ设置初值，车辆便可以正常运行起来了。</p><h6 id="还有什么问题"><a href="#还有什么问题" class="headerlink" title="还有什么问题"></a>还有什么问题</h6><p>​时间匆忙，没有写好取任务的逻辑，之前尝试写取任务的逻辑时可能存在一些小问题（企图用引用直接修改数组）最终并没有在本周把此逻辑完成。</p><p>​其次，变速问题，从上文可看到本文只是使用了一个很简单的恒速油门进行驱动，并没有编写变速和停车的逻辑。或许可以根据装载任务的缓冲区进行变速调整。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>UE5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UE5 AI模块 学习记录</title>
    <link href="/2025/02/13/UE5-AI%E5%B7%A5%E5%85%B7%E7%AE%B1-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2025/02/13/UE5-AI%E5%B7%A5%E5%85%B7%E7%AE%B1-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>​本博客记录UE5的AI相关工具的学习过程。</p><blockquote><p>参考课程：</p><ul><li><a href="https://www.bilibili.com/video/BV1dz4y1A7G3?spm_id_from=333.788.videopod.episodes&vd_source=e3bc0a74b003e86cc67e459d9355420a">虚幻引擎倾囊相授计划：AI行为树系统教程（上）_UnrealEngine_AI Behavior Tree_UE5_虚幻5_哔哩哔哩_bilibili</a></li></ul></blockquote><h3 id="行为树"><a href="#行为树" class="headerlink" title="行为树"></a>行为树</h3><h4 id="行为树基础"><a href="#行为树基础" class="headerlink" title="行为树基础"></a>行为树基础</h4><p>​UE5中，需要驱动NPC，要用行为树</p><p>​一个行为树和一个黑板绑定，在行为树内创建黑板会自动绑定，否则需要手动绑一下（就右边）</p><p>​黑板建立变量，为行为树决策提供目标和记录，总之就是行为树会用到的变量的集合。</p><p>​配合AI控制器类就可以构造受AI控制的NPC了</p><p>​流程：创建AI控制器蓝图，让其运行行为树-&gt;NPC类绑定AI控制器</p><p>​可以在AI界面设置断点Debug来查看行为模式的变换</p><h4 id="行为树复合节点"><a href="#行为树复合节点" class="headerlink" title="行为树复合节点"></a>行为树复合节点</h4><p>​主要是选择节点和序列节点</p><ul><li>选择节点：从左到右为对应优先级，选择第一个成功任务进行运行，运行后返回</li><li>序列节点：从左到右为对应优先级，执行全部任务，遇到失败任务或全部运行结束后返回<ul><li>遇到失败任务后后续节点都不会执行！</li></ul></li></ul><p>​从左到右这个优先级是一致的，所以节点顺序是重要的</p><h4 id="随机巡逻的实现"><a href="#随机巡逻的实现" class="headerlink" title="随机巡逻的实现"></a>随机巡逻的实现</h4><p>​使用导航网格体积标注NPC的可移动范围（有没有办法让NPC全图可动？）</p><p>​利用复合节点和Task节点构造行为树，黑板中的变量可以同行为树的Task进行关联从而影响NPC动作，可在上方新建任务</p><p>​注意事件选择AI相关事件</p><p>​同时应该注意，此处自定义任务开始需要接触简单蓝图编程，其跟一般的编程会有些不一样，注意学习蓝图Debug技巧和常用的蓝图节点函数，积累一些常用节点</p><p>​要让Task和黑板通信，需要用到“黑板键选择器”类型的变量，同时这个变量必须可见。可以将黑板键设置为不同的类型。</p><p>​黑板键选择器变量对外可见，可将这个黑板键选择器承载的值赋予外部黑板的某个指定变量（解耦）</p><p>​手动任务要在末尾加上一个“完成执行”的节点，这样能正常完结一个任务，属于语法问题</p><h4 id="导航边界的获取"><a href="#导航边界的获取" class="headerlink" title="导航边界的获取"></a>导航边界的获取</h4><p>​可以通过获取NavMesh的边界（利用获取类的Actor-&gt;获取Actor边界）来实时更新NPC的有效导航范围，其原点坐标是中心的坐标</p><p>​Box extent是类似于半径的一个概念</p><p>​对于人物而言，小心设置Z轴，最好选用人物本身的Z坐标作为导航区域Z轴的设置</p><h4 id="平行合成节点"><a href="#平行合成节点" class="headerlink" title="平行合成节点"></a>平行合成节点</h4><p>​在运行一个叶节点任务的同时复合进行部分任务，这个叶节点任务是主任务</p><p>​我偏向于理解成附加任务的叶节点</p><p>​比如说边移动边播放音效这种事情</p><p>​装饰器可以为节点添加限制性内容</p><p>​并行完成模式：</p><ul><li>直接模式：主任务完成就算完成</li><li>已延迟：全部完成才算完成<ul><li>可以用多线程相关知识理解</li></ul></li></ul><h4 id="正向固定点巡逻"><a href="#正向固定点巡逻" class="headerlink" title="正向固定点巡逻"></a>正向固定点巡逻</h4><p>​ 为NPC类建立巡逻点数组，此数组存储寻路点Actor，从而完成寻路措施（也许可以做成一个静态队列）</p><p>​黑板键选择器这一类变量，类似于不定类型的变量，需要使用特定节点将其以指定类型的数据进行读取后才可以使用，也需要用特定节点对其进行设置</p><p>​对黑板键选择器类型变量的初始化放在“运行行为树”后进行是OK的，支持按名为黑板键设置初始值</p><h4 id="反向固定点巡逻"><a href="#反向固定点巡逻" class="headerlink" title="反向固定点巡逻"></a>反向固定点巡逻</h4><p>​利用装饰节点和黑板的变量， 控制NPC的正向和反向巡逻</p><p>​总体而言黑板和行为树是不可分割的，耦合很大的一个系统</p><p>​注意了解“观察器终止”选项这些选项的含义</p><h4 id="服务节点"><a href="#服务节点" class="headerlink" title="服务节点"></a>服务节点</h4><p>​装饰器&#x3D;条件，服务&#x3D;嵌套在节点上的额外配置</p><p>​根据UE5文档的描述，它们常用于<strong>检查和更新黑板</strong>，取代了传统行为树系统中的“<strong>平行节点</strong>”</p><p>​<strong>装饰器决定某个分支是否可以被执行</strong></p><p>​<strong>服务</strong>是不断检查状态然后更新黑板的</p><h4 id="视觉感知"><a href="#视觉感知" class="headerlink" title="视觉感知"></a>视觉感知</h4><p>​AI知觉主要包括视觉，听觉和触觉</p><p>​可以在AI控制器或者NPC蓝图中添加AI感知组件</p><ul><li>关于双层视线<ul><li>一般是扇形外扣一个截圆环的样子，扇形半径是视线半径，截圆环的半径是失去视线半径</li></ul></li></ul><p>​视觉检测的“按归属检测”可能要配合C++完成，具体有待查询更多</p><p>​视觉debug，可按引号键查看当前NPC的视觉区域，小键盘4可查看当前NPC的总的感知范围</p><h4 id="预感感知"><a href="#预感感知" class="headerlink" title="预感感知"></a>预感感知</h4><p>​这个感知可以让NPC尝试预测玩家所处方位</p><p>​谁预感，预感谁，预感对象将来一定时间后出现的位置这个一定时间是多少</p><p>​要设置的比较少</p><p>​这里头有一套引擎自己实现的算法，设置内容不算很多</p><p>​注意感知类型判断要和实际的判断分开写，否则可能发生错误</p><p>​观察黑板值这个选项可以实时定位新的值</p><h4 id="听力感知"><a href="#听力感知" class="headerlink" title="听力感知"></a>听力感知</h4><p>​根据玩家发出的噪声判定玩家的方位，NPC也有一定听力范围</p><p>​别的感知类似，此处就不再赘述，跟课题关联不是很大</p><h4 id="多NPC感知冲突"><a href="#多NPC感知冲突" class="headerlink" title="多NPC感知冲突"></a>多NPC感知冲突</h4><p>​优先判断是不是玩家，将玩家判断提前</p><h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>​可以跟黑板变量关联，进行逻辑判断，或者执行流的变换（如Loop）</p><p>​是承载逻辑结构的东西</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>UE5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的UE5学习历程&amp;阶段目标</title>
    <link href="/2025/01/20/UE5%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/"/>
    <url>/2025/01/20/UE5%E5%AD%A6%E4%B9%A0%E5%8E%86%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>​本博客作为留档使用，用来记录2025寒假期间UE5的相关学习记录和历程。</p><p>​本次学习为任务驱动式的学习，预期制作一个交通仿真系统的简单原型。</p><p>​（四级标题以周为单位，五级标题是周报，六级是知识点的实现和实践尝试）</p><h3 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h3><p>​制作交通仿真系统前端，现在预期希望解决这些问题：</p><ul><li>如何搭建一个城市？</li><li>如何制作车与人的模型，并且让他们运动起来？<ul><li>在此基础上，如何让他们按照我希望的运动逻辑进行运动？</li><li>如何遵照后端指示运动？</li></ul></li><li>如何搭建一个简易UI界面？</li><li>如何让他们依照交通规则运转（如何为他们配置AI进行运动？）</li></ul><h3 id="学习历程"><a href="#学习历程" class="headerlink" title="学习历程"></a>学习历程</h3><p>​此学习历程逐周进行记录。</p><h4 id="W1"><a href="#W1" class="headerlink" title="W1"></a>W1</h4><p>​对于我而言，UE5是一个全新的领域，所以首要目标就是尽快熟悉UE5的基本功能和与本任务相关的功能应该如何实现。受时间所限，问题被局限为：</p><ul><li>基本功能有哪些？</li><li>UE5是如何进行逻辑控制的？</li><li>如何设计简单UI？</li></ul><blockquote><p>思考：</p><p>UE5功能繁多，但是基本功能有什么呢？仿真虽然不是游戏但是工程操作应该是共通的。</p><p>当前侧重点应该放在城市模型构建和AI配置上。至于UI首先希望能跑就行，美观程度啥的非重点</p></blockquote><blockquote><p>资料参考：</p><p><a href="https://www.bilibili.com/video/BV1Cd4y1V7G5/?spm_id_from=333.999.0.0&vd_source=e3bc0a74b003e86cc67e459d9355420a">【虚幻引擎】爆肝两个月！拜托三连了！这绝对是全B站最用心的UE5.1全中文新手入门公开教程，耗时千余小时开发！_哔哩哔哩_bilibili</a></p><p>这个视频系列简单介绍了虚幻引擎的常用系统的入门，以及可以去哪里下载公用免费资产。</p><p>对于我们这种美术要求不高的项目而言很重要。</p><p><a href="https://www.bilibili.com/video/BV1iz4y1s7Kh?spm_id_from=333.788.videopod.sections&vd_source=e3bc0a74b003e86cc67e459d9355420a">【欧酱UE5】_1#蓝图基础介绍_虚幻引擎游戏蓝图入门_哔哩哔哩_bilibili</a></p><p>这个视频系列主要聚焦于虚幻蓝图系统的使用，通过一个简单的游戏案例让我学习如何实现人物动画的简单设置，以及基于事件的蓝图编程。同时此教程涉及简单UI设计，同时可作为UMG入门使用。</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/unreal-engine-5-5-documentation">虚幻引擎5.5文档 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p>虚幻文档——创建用户UI界面&amp;编程和脚本编写（两个部分）</p></blockquote><p>​关于用户UI界面，主要介绍UMG的使用，可以利用UMG系统构建简单UI并且实现UI同场景内Actor的信息的绑定，这一点可以明确做到。（跟之前调研的MassTraffic有些不同，不过如果MassTraffic也是生成Actor的话或许有办法直接获取数据？）</p><p>​编程和脚本编写，主要聚焦于蓝图脚本的使用方法。这个可视化编程脚本可以用OO的思维模式理解。这个东西除了可以直接连线进行组件间沟通（术语是直接通信），还存在接口通信（UE5有接口继承的方式），<strong>事件通信</strong>（这个很重要）和cast转换（主要是用于访问特殊子类的操作）。这当中可能会认为事件通信很重要，因为事件的订阅和通知正好就是我们仿真系统希望实现的功能（车辆接送乘客）的本质。</p><p>​同时对于之前提到的时间，事实上模拟不可能按照正常时间尺度进行，不然我们会很难获取结果。因为每个Actor都自带一个逐帧计时的事件的功能，或许可以以帧为单位适当压缩时间尺度进行模拟，对于时间的控制，上方第二个教程有提到过全局时间控制的功能，或许可以一用。</p><p>​中文资料确实不太多，应该放眼油管再看看。</p><blockquote><p>实践上希望完成什么呢？</p><ul><li>按帧模拟日出日落（测试时间）</li><li>Houdini与城市</li><li>让车和人先动起来（人的话是有提过MetaHuman的，资产的问题恐怕是）</li><li>UMG的UI设计，先摆摆看再说</li></ul></blockquote><h5 id="实践尝试"><a href="#实践尝试" class="headerlink" title="实践尝试"></a>实践尝试</h5><h6 id="时间系统"><a href="#时间系统" class="headerlink" title="时间系统"></a>时间系统</h6><p>​需求:</p><ul><li>显示时间</li><li>每一帧更新，一帧视为一秒</li><li>太阳光跟随，按时间日出日落</li><li>运行时不允许修改时间，要能暂停世界，暂停后运行修改时间</li></ul><p>​出于对模拟精度的要求，Sunsky Actor这种可以有效根据地理位置进行太阳光照模拟的插件比自带的光源更好（其本质就是一个打包的定向光源），通过对其中的日期和时间参数进行更改我们就可以获得较好的模拟体验。</p><p>​通过蓝图更改Date,Solar Time和经纬度可以较好的模拟定期的日升日落。同样的逻辑有希望作用于别的时控逻辑。</p><p>（注：由1.24组会讨论，取消此实践尝试，转由别的方案解决）</p><h5 id="W1周报"><a href="#W1周报" class="headerlink" title="W1周报"></a>W1周报</h5><ul><li>本周的工作聚焦UE5的入门，预期是W1~W2都专注于学习UE5的基础功能</li><li>本周学习的内容包括：<ul><li>虚幻编辑器的基本使用方式（基本S&#x2F;L；设置；资产的获取，导入和使用；环境光照设置）</li><li>虚幻工程的命名准则，工程文件的基本构成</li><li>材质贴图UV等的使用</li><li>简单光源的使用</li><li>蓝图（重点）（蓝图脚本是OO）<ul><li>蓝图基础（什么是蓝图？关于关卡蓝图和Actor蓝图？如何使用蓝图控制简单逻辑？如何Debug蓝图系统？）</li><li>基于事件驱动的蓝图脚本编程（绑定事件，分发事件，响应事件）</li><li>蓝图中的简易碰撞设置</li><li>动画蓝图的制作（动画状态机）&amp; 使用时间轴制作简易动画</li></ul></li><li>简易UI制作（UI控件入门）</li></ul></li><li>侧重应该在系统构建而非UI，现阶段希望UI能跑就行；更多的精力应该放在城市构建上；</li><li>利用Houdini进行程序化街区生成将会放在W2进行学习；同时可能会尝试寻找是否存在更好的自动化生成方案；</li><li>本周的蓝图涉及的是如何让人和车辆动起来的部分；AI蓝图并未放在本周而是预期放在W2进行学习；</li></ul><h4 id="W2"><a href="#W2" class="headerlink" title="W2"></a>W2</h4><p>​本周任务侧重于以下几个方面：</p><ul><li>基于OSM的程序化生成城市的研究&#x2F;利用Houdini生成城市的研究（二选一，只要能搭建城市就行）</li><li>让一个人和一辆车动起来</li><li>寻找将UE5程序打包至常用Web前端的方案</li></ul><p>​基于任务，认为需要侧重以下方面的学习：</p><ul><li>蓝图<ul><li>AI交互</li><li>MassTraffic</li><li>动画</li></ul></li><li>载具——车辆如何动起来</li></ul><p>​针对W1组会的问题：</p><ul><li>明确学习重点，需要搞清楚需要学习哪一块的知识，有针对性</li></ul><h5 id="实践要求"><a href="#实践要求" class="headerlink" title="实践要求"></a>实践要求</h5><h6 id="基于OSM的程序化生成城市的研究"><a href="#基于OSM的程序化生成城市的研究" class="headerlink" title="基于OSM的程序化生成城市的研究"></a>基于OSM的程序化生成城市的研究</h6><p>​这个课题是由W0组会带来的，手动构建一个城市费时费力，是否存在一个办法高效的自动化生成城市？</p><p>​组会上学长提到了一种称为OSM的文件格式，希望以此作为切入点。</p><p>​展开调研分析可知，这种文件格式是由OpenStreetMap组织提供的，基于点，路，区块构造的一类地图文件。基于此文件的快速城市构造引出了Houdini和CityEngine两个软件。</p><p>​Houdini是一个经典而强力的建模特效软件，它胜在功能多样，能执行很多任务；但是它的不足在于学习成本很高，不适宜8周短暂实习的敏捷开发环境。</p><p>​而CityEngine则是专门用于3D城市建设的一个软件，支持OSM。这个软件功能单一但操作简单，虽然生成效果不如Houdini但是胜在简便。因此实际进行OSM程序化城市生成的时候选用的是这个软件。</p><p>​OSM生成城市的技术路径是：由OpenStreetMap官网截取OSM文件-&gt;导入CityEngine中，适当处理导入数据后，生成城市模型和路网模型-&gt;CityEngine导出udatasmith文件-&gt;UE5导入udatasmith文件从而生成模型。</p><p>​注意以上操作暂时需要手动完成，但CityEngine开放python脚本编程。这意味着可以通过调用API接口的方式使本软件完成自动化建模（即UE5调用外部python脚本完成自动化构建），这个暂时不在本次任务研究范围之内。</p><p>​以下是各步骤的实行截图：</p><p>​首先我们从OSM当中截取一个区块</p><p><img src="/img/Posts/WeeklyReport/OSM-1.png" alt="截取区域"></p><p>​紧接着下载此OSM文件，并且导入CityEngine：</p><p><img src="/img/Posts/WeeklyReport/OSM-2.png" alt="将OSM导入CityEngine"></p><p>​由于OSM数据本身的原因，可能存在需要额外手动编辑的部分，在手动修正区块模型之后进行生成（建筑和路网）：</p><p><img src="/img/Posts/WeeklyReport/OSM-3.png" alt="生成城市"></p><p>​最后，导出udatasmith，并且导入UE5，最终效果如下图所示：</p><p><img src="/img/Posts/WeeklyReport/OSM-4.png" alt="导出到Unreal"></p><p>​至此，本课题完成。</p><p>​备注：用于数字孪生城市的建模的数据结构，发现存在一种叫做CityGML的数据结构。或许可以更好胜任任务。但本周并不打算就这个话题继续深入探究。等之后有空再回来填坑。</p><p>​先把资料链接放在这里：<a href="https://zhuanlan.zhihu.com/p/234846577">数字孪生城市的建筑模型处理技术简介 - 知乎</a></p><h6 id="调研将UE5项目打包到前端框架部署的方案"><a href="#调研将UE5项目打包到前端框架部署的方案" class="headerlink" title="调研将UE5项目打包到前端框架部署的方案"></a>调研将UE5项目打包到前端框架部署的方案</h6><p>​UE5的部署据调研跟常规Web前端存在差异。</p><p>​常规Web网页可做到同页不同态，其实质是将网页对应的超文本文件下载到本地后再使用浏览器渲染，并且基于Cookie的状态识别机制实现不同状态的切换。它的实质类似于本地客户端同后端服务器交互的模式。而这显然不是我们本次希望使用的模式，本次我们并不打算构建客户端并且让用户下载到本地。这涉及安全和推广等的问题。</p><p>​对于UE5，我们无法让一个应用实例供多个客户共享，我们也无法让客户下载本地客户端从而进行交互。在这种情况下应该如何合理布局呢？目前调研能得到的答案是“多实例部署像素流送”。</p><p>​简而言之如下图所示：</p><p><img src="/img/Posts/WeeklyReport/PixelStreamingFrame.png" alt="像素流送框架图"></p><p>​这个部署方式的核心分别是“像素流送”和“多实例部署”，接下来一一解析。</p><p>​“像素流送”是UE远程部署的核心技术。现在广泛应用于云游戏中。它的做法类似于远程桌面，服务器在远端使用高配置进行运算，而后将运算后的画面和音频传回本地客户端，从而实现交互。UE5本身支持“像素流送”技术，需要启用原生插件。在进行程序打包和额外命令行设置之后，打包后的程序可以在服务端启动一个实例，并且通过公网端口供客户进行交互，一个实例绑定一个端口。</p><p>​“多实例部署”就是启用多个实例。在调研的早先阶段所参考的案例基本都是“单实例部署”，这样的结果就是不支持共享，当同一个实例被多个客户访问，只有一个客户能正确使用实例。解决办法是“多实例部署”，在启动程序时在新的端口生成程序实例并且移交客户使用，这样便可以有效解决这个问题。呈现出来的效果也如上图流程所示。</p><p>​这样部署存在部分问题：</p><ul><li>程序服务器性能要求极高</li><li>程序服务器可能存在爆满风险（端口不够用&#x2F;性能到达极限）</li><li>对程序服务器集群构架提出了严苛要求（要能主动负载均衡，正确导流）</li></ul><p>​（所面临的这些问题和游戏服务器面临的问题多少存在相似关系，题外话）</p><p>​（如果希望根据用户提交信息调用对应的用户数据存档，需要用到UE5自带的S&#x2F;L机制）</p><p>​（而话说回来，可以刻意分配同实例给不同客户，这样便可以完成协同共享功能）</p><blockquote><p>参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/625185394">UE5–像素流多实例公网部署 - 知乎</a></p><p><a href="https://blog.csdn.net/tianxiaojie_blog/article/details/116450068">简单实现局域网内实现像素流送的负载均衡_像素流送多人访问-CSDN博客</a></p><p><a href="https://www.bilibili.com/video/BV1V94y1V7vj/?spm_id_from=333.337.search-card.all.click&vd_source=e3bc0a74b003e86cc67e459d9355420a">【UE教程】Ue5+Vue像素流送教程分享_哔哩哔哩_bilibili</a></p><p>（备注：参考资料3证明了将像素流嵌入前端框架的可行性）</p><p><a href="https://www.bilibili.com/video/BV18V411N7gz/?spm_id_from=333.999.0.0&vd_source=e3bc0a74b003e86cc67e459d9355420a">离谱！我竟然成功的在网页上运行了虚幻引擎！！！_哔哩哔哩_bilibili</a></p><p>（备注：这个视频有在开头说明完整的技术栈）</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/pixel-streaming-in-unreal-engine">虚幻引擎像素流送 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p></blockquote><h6 id="让人动起来"><a href="#让人动起来" class="headerlink" title="让人动起来"></a>让人动起来</h6><p>​很不幸的是这个实践的完成难度有些过高了，为这个任务分配了3天时间学习但是没有办法完成哪怕一半的进度。</p><p>​原本分配的任务是“让人和车动起来”。正如之前在周简报起头所提到的，这个任务更多聚焦于AI蓝图和动画蓝图的学习和应用，但是在实际实施过程中遇到了很多困难。</p><p>​这个实践有一个巨大问题在于我的电脑配置，3060 6G显存的配置导致虚幻编辑器天天卡成PPT，这是一个方面；另一个方面就是AI和动画这两个方面的工具箱都具有相当的复杂度，在我查阅文档和翻找各种视频资料时，对于动画资产的迁移，绑定，混合等操作都存在诸多疑问。</p><p>​所以最后实践目标只能被迫变成“先让人动起来”吧。</p><p>​如果要考虑全程的实现的链条，那应该是这样的：让人和车具有动画，能动起来-&gt;（人和车的动画交互就先不考虑了，我感觉两个月内不大能做的出来）让车辆和人能接收指定参数-&gt;让车辆和人能根据指定参数移动起来-&gt;让一群人和一群车根据指定参数动起来</p><p>​针对让人动起来的办法，参考资料：</p><blockquote><p><a href="https://blog.csdn.net/ChaoChao66666/article/details/138962473">【UE5.1】* 动画重定向 （让你的角色可以使用小白人全部动画）_ue5 动画重定向-CSDN博客</a></p><p><a href="https://dev.epicgames.com/documentation/zh-cn/metahuman/retargeting-animation-blueprints-to-metahumans-in-unreal-engine#%E6%89%80%E9%9C%80%E7%9F%A5%E8%AF%86%E5%92%8C%E5%87%86%E5%A4%87">使用虚幻引擎动画蓝图将动画重定向到MetaHuman | MetaHuman 文档 | Epic Developer Community</a></p></blockquote><p>​针对人，素材倒是不需要很担心，因为虚幻本身的Quixel Bridge资产库当中存在若干仿真数字人的免费资产。考虑人物多样性的话勉强够用。</p><p>​紧接着，需要考虑如何为数字人添加动作。这是难点。实际上示例项目当中存在默认角色，它们本身就带有基础的动作动画（在这里我走了一个弯路浪费了半天的时间QAQ），通过动画重定向能够将默认角色的动画绑定到数字人身上。具有可行性，截止目前尚在实践尝试中。</p><p>​预期是希望根据速度变更数字人的走路和暂停动作，若之后完成了此项实践则会将结果后附。</p><p>​IK绑定要比预想中简单，因为虚幻提供了自动IK功能，以及迁移的双方（默认角色和预设的数字人）他们的骨架是相同的结构，所以动画迁移并没有那么困难了。但是对于几种不同的角色，动画要同时迁移好多次，可能是一个体力活。</p><p>​在尝试绑定角色操控时发生问题，角色无法接收输入并且移动。</p><p>​最后使用官方方案（资料2），在实际操作过程中发现骨骼体用错了，但是最后完成也是完成了。最后得到的人物具有严重的滑步问题和转向问题。说明自制的动画蓝图效果并不是很好。交互动画是比较难做的。不过，幸好可以直接将默认动画蓝图绑定给角色。最终角色拥有较好的移动效果。算是勉强完成了让单个角色动起来的任务。</p><p>​绕弯路的过程中也学习了IK绑定，基础角色蓝图制作等，针对这一系列步骤由于表述是较为繁琐的所以建议就是直接附上相关技术文档就是了。因为操作起来确实按部就班。有可能还需要多使用几次蓝图来慢慢理解蓝图究竟在干啥（这玩意和普通编程感觉还是有些差距的，我的情况有些类似于不知道有什么常用库函数可以调用&amp;专门模块的库函数是可以做什么的）</p><p>​另外人物蓝图这一块是完成了基本的动画绑定，但是目前能做到的就是人物制作和绑定动画而已，至于给人物适配AI控制器……这一部分涉及AI蓝图了，实在是非常头疼的事情……</p><p>​其他参考资料：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1LCtfedE9D/?spm_id_from=333.337.search-card.all.click&vd_source=e3bc0a74b003e86cc67e459d9355420a">UE5.4一键生成NPC_哔哩哔哩_bilibili</a></p><p>这种生成有点像我预想中的AI人群的生成效果，但是MassAI这里的路径规划也是一个较为麻烦的事情</p></blockquote><h5 id="知识点记录"><a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h5><h6 id="事件分发机制"><a href="#事件分发机制" class="headerlink" title="事件分发机制"></a>事件分发机制</h6><p>​UE的事件分发机制简而言之其实就是“监听——广播”的机制。之所以需要再强调一下是因为形式上稍微有些不理解。</p><p>​参考这篇博客：<a href="https://www.bilibili.com/opus/842531201764818946">一篇文章看懂UE事件分发器怎么用 - 哔哩哔哩</a></p><p>​借用这个文章的几张图说自己的理解</p><p><img src="/img/Posts/WeeklyReport/EventHandler1.png" alt="EventHandler1"></p><p>​这张图的意思是“调用事件”，我为这个Actor设置了某个事件，在一定条件下它会调用这个事件。</p><p><img src="/img/Posts/WeeklyReport/EventHandler2.png" alt="EventHandler2"></p><p>​这是监听端，开始运行后会激活这个监听器（“绑定事件到BOSS挂了”这个东西，我倾向于把它理解成是一个特定语法的监听器，目标指的是监听的哪一个Actor，事件指的是监听哪一个事件，综合而言就是监听X对象的E事件），然后监听器会挂载一系列事件调用（以那个事件作为接口）（一切理解成语法原因就行）</p><p><img src="/img/Posts/WeeklyReport/EventHandler3.png" alt="EventHandler3"></p><p>​最后是最末端的事件，收到上方的调用后会激活这个事件。</p><p>​<a href="https://www.bilibili.com/video/BV1nQSUYTEAv/?vd_source=e3bc0a74b003e86cc67e459d9355420a">【双字精译】虚幻引擎中的接口与事件分发器——Ali Elzoheiry_哔哩哔哩_bilibili</a></p><p>​借由这个视频可知存在，第二张图中的那个更为怪异的语法存在一个优势，那就是可以自由解绑捆绑。</p><h6 id="IK绑定"><a href="#IK绑定" class="headerlink" title="IK绑定"></a>IK绑定</h6><p>​简单来说就是根据骨架信息进行动作的同步。不同的骨架构造出相似的骨架组，然后骨架组之间进行匹配。构造骨架组是IK绑定，而骨架动作同步则是IK重定向器。借助这个工具可以轻松实现动画序列的换模。虽说最终解决方案并没有用到IK绑定但是不可否认的是IK绑定是一个很好用的工具。</p><h6 id="角色蓝图构造-虚幻蓝图基础类型的重新学习"><a href="#角色蓝图构造-虚幻蓝图基础类型的重新学习" class="headerlink" title="角色蓝图构造&amp;虚幻蓝图基础类型的重新学习"></a>角色蓝图构造&amp;虚幻蓝图基础类型的重新学习</h6><p>​这一块记录我在让人动起来这个过程中踩的一些坑。</p><p>​首先是Actor和Pawn（Character），这次踩坑让我重新复习了这三类基础蓝图。MetaHuman下载下来的时候是Actor文件，它是不能直接通过更换父类来做到使用的（实践中踩的坑，直接替换父类仍然无法使用）。正确的换模应该是新建Character然后将网格体复制过去。需要重新再来强调这3类文件，Actor这个类我倾向于理解成Unity的GameObject，这玩意是游戏当中放置的各种东西的一个大的基类，而Pawn则是Actor中可以操控的类（Character则是Pawn的更细化的一个特例，它可以胜任复杂的动作）。所以根据这一点和实践来看，Actor直接特化为Pawn应该是一个不可行的思路。</p><p>​第二是蓝图的制作，这一点我只能说尚在摸索当中。在周会后我还需要将本次使用的EnableMasterPose函数进行分析。不知道为什么我觉得蓝图的学习有些难以下手，可能需要花一些时间复盘一下这个问题。最好的办法恐怕还是要拆解一下官方案例学习一下。另外，基于Character外接AI控制器这个想法虽然具有一定可行性，但是考虑多人物渲染会不会出问题，这就是一个有待继续讨论的话题了。最后很惊讶于能直接使用默认动画蓝图（默认蓝图是给默认骨骼使用的，虽说预设数字人的骨骼结构和默认骨骼一致但是实际上是两个文件，还以为会存在文件归属问题）</p><h4 id="W3"><a href="#W3" class="headerlink" title="W3"></a>W3</h4><p>本周希望解决的问题包括：</p><ul><li><p>CityEngine是否兼容多车道生成？</p></li><li><p><strong>借助CityEngine的库不需要GUI就能生成并导出建筑</strong></p></li><li><p><strong>端口占用情况随实例动态增减的方案？前端部署方案能否追加端口管理方案？</strong></p></li><li><p>UE5运行卡顿这个问题是为何？</p></li><li><p><strong>车怎么动起来</strong></p></li><li><p><strong>多人多车运动&#x2F;人车交互</strong></p></li></ul><p>​以最后两个问题最难，由W2的实践来看的话。</p><p>​本周将正式投入工程制作中，并不清楚能做到什么程度，希望能够完成最终任务吧QAQ</p><p>​很遗憾的是就调研情况而看标黑的这四个问题几乎都是重量级问题:(</p><h5 id="实践要求-1"><a href="#实践要求-1" class="headerlink" title="实践要求"></a>实践要求</h5><h6 id="UE5为什么卡顿"><a href="#UE5为什么卡顿" class="headerlink" title="UE5为什么卡顿"></a>UE5为什么卡顿</h6><p>​首先是我本身配置比较低。我的显卡是3060 6G显存，电脑的话是48G内存（当然要拓展成64G内存的话还是简单的），主要问题还是在显卡上。3060本身还是OK的，是6G显存限制了我的电脑。这里需要贴一张推荐配置。</p><p><img src="/img/Posts/WeeklyReport/UnrealSettings.png" alt="虚幻5推荐配置"></p><p>​可以看到官方的要求是上到了3080 10GB的，显存可以说是缺失得相当严重的。因而判定只要问题还是在显存上。</p><p>​其次是配置开的很高，根据设置发现开的渲染品质默认是“极高”，显然是不太符合我电脑当前配置一个等级，故而把它进行调低。最后确定在“低”情况下能够较为稳定地保持在60fps左右。此问题得到初步改善。</p><h6 id="CityEngine城市生成的进一步研究"><a href="#CityEngine城市生成的进一步研究" class="headerlink" title="CityEngine城市生成的进一步研究"></a>CityEngine城市生成的进一步研究</h6><p>​首先可以明确的是，CityEngine它确实支持多车道生成。我们采用NewYork的某地方：</p><p><img src="/img/Posts/WeeklyReport/Mahattan.png" alt="示例地区截取"></p><p>​以它作为源文件生成地图之后：</p><p><img src="/img/Posts/WeeklyReport/CorrectRoad.png" alt="正确生成多车道"></p><p>​这是截取的某一部分的车道拓宽图，从这张图来看CityEngine确实可以较好地生成多车道，它具有这样的能力。但是从同样的一份数据中：</p><p><img src="/img/Posts/WeeklyReport/WrongRoad.png" alt="错误生成的立交桥"></p><p>​它的高架桥生成的比较凌乱，包括之前的测试中环岛一块CityEngine的生成也并不是那么优秀。这暗示着CityEngine对于复杂地形的生成可能存在一定的不足。这个问题目前看来难以解决，大概率需要依靠手动修正。如果可以的话希望避开这个问题（</p><blockquote><p>备注参考资料：</p><p><a href="https://zhuanlan.zhihu.com/p/349455097">自动驾驶系统之软件仿真测试 - 知乎</a></p><p>如果CityEngine一个程序解决不了这个问题，路网就得别的软件生成了。</p><p><a href="https://juejin.cn/post/7366567675316125705">参数化建模系列-cityengine篇之：如何基于GIS数据快速构建道路三维建模模型结合上期介绍的基于GIS数据自动化构 - 掘金</a></p><p>CityEngine存在CGA规则生成方法，这个方法需要投入精力去学习，也比较复杂，不亚于学一种新的语言，作为一种具有一定可行性的方法放在这里进行参考。</p></blockquote><h6 id="CityEngine能否避开GUI进行城市路网生成-导出"><a href="#CityEngine能否避开GUI进行城市路网生成-导出" class="headerlink" title="CityEngine能否避开GUI进行城市路网生成&amp;导出"></a>CityEngine能否避开GUI进行城市路网生成&amp;导出</h6><p>​这个问题或许需要一个更加准确的问法，这个问法是没有达到预期的。</p><p>​CityEngine本身开放有Python编程接口，可以直接编写脚本批量化处理，简单易行。</p><p>​但是CityEngine并没有提供命令行接口，这些编程接口都无法脱离CityEngine而存在。所以CityEngine实际不能集成入软件中。</p><p>​那有没有破解方法呢？调研目标或许得找到“库”之类的程序。</p><p>​CityEngine提供C++ SDK和PyPRT两个解决方案。其中由于我对C++并不是很熟悉，所以我选择重点调研PyPRT的方案。PyPRT保留了CityEngine中最核心的功能（生成模型）而别的一概没做。选用这个方案的话需要自己处理OSM转换到Initial Shape（其给定的生成模型的初始格式）的逻辑。</p><p>​还有一个Blender+OSM的方案，与CityEngine的功能类似。但是不同之处在于Blender是一个开源软件，可以使用bpy库以库的方式调用Blender的功能。但是这个方案仍有待检验。</p><p>​对于我们软件而言，如果需要快速生成城市，我觉得一个可行的办法是基于PyPRT库（有C++能力的话最好选用C++ SDK）制作生成模块。与CityEngine方式的思路会比较相似，相对容易迁移。</p><blockquote><p>参考资料</p><p><a href="https://esri.github.io/pyprt/apidoc/index.html">PyPRT API Documentation — Python documentation</a></p><p><a href="https://esri.github.io/cityengine-sdk/html/esri_prt_codecs.html">esri.github.io&#x2F;cityengine-sdk&#x2F;html&#x2F;esri_prt_codecs.html</a></p><p>这个资料列出了PyPRT（CityEngine C++ SDK）支持的编码解码格式，其中至少看到支持Unreal Engine了</p><p>（清华的UrbanWorld课题貌似也是在解决这个难题的，如果能直接从这个课题组集成过去的话说不定也不错……）</p></blockquote><h6 id="是否有端口随实例动态增减的解决方案存在"><a href="#是否有端口随实例动态增减的解决方案存在" class="headerlink" title="是否有端口随实例动态增减的解决方案存在"></a>是否有端口随实例动态增减的解决方案存在</h6><p>​这个问题意外是一个比较难解决的问题，以此问题为基点可以阐述很多东西。或许正是因为涉及的很多导致这个问题的可讨论性是比较大的。</p><p>​这个问题能够牵扯的东西包括整个仿真软件系统的总体架构。根据调研的结果来看我们正在制作的仿真系统恰好也符合“云原生”的理念。<strong>云原生是在云计算环境中构建、部署和管理现代应用程序的软件方法。</strong>现代企业希望构建高度可扩展、灵活且具有弹性的应用程序，可以快速更新以满足客户需求。为此，他们使用现代工具和技术，这些工具和技术本质上支持云基础设施上的应用程序开发。这些云原生技术支持快速、频繁地更改应用程序，而不会影响服务交付，从而为采用者提供了创新的竞争优势。云原生的技术栈也是一个相对而言较大的课题，是相当丰富的，这里姑且就这样吧。</p><p>​然后是容器化。云原生的一个重点就是容器化，指把应用及其环境打包成容器，实现生产和部署环境的一致以及轻量化管理。对应用的管理可以最终抽象成对容器的管理。而这其中最为典型的技术栈就是K8S+Docker了，这两个软件足以胜任大型集群管理（辅以Portainer等可视化工具更甚）。这个技术栈使用的最为广泛，足以胜任大型环境，所以调研的出发点就是他。倒不如说我只能想到这个技术栈。</p><p>​而这里就存在这个问题了。Docker容器支持容器内外端口映射，但是存在限制：要么一对一精确端口映射，要么对等端口映射，要么支持指定范围内的随机端口映射（无法自定义映射范围）。当前Docker支持的这三种映射方案没有一种是满足所需要求的。比较趋近于我们希望的方案的是第三种方案（随机映射）。</p><p>​无论何种方案，基本都绕不开容器和Docker，也许应该考虑从Docker这个限制出发想可能存在什么别的编排方案……</p><blockquote><p>关于云原生的参考：</p><p><a href="https://cloud.tencent.com/developer/article/2412041">云原生及其技术栈介绍-腾讯云开发者社区-腾讯云</a></p><p><a href="https://www.bilibili.com/video/BV1ZG411G7Vo/?spm_id_from=333.337.search-card.all.click&vd_source=e3bc0a74b003e86cc67e459d9355420a">最简单类比-搞清云原生核心底层逻辑_哔哩哔哩_bilibili</a></p></blockquote><h6 id="让车动起来"><a href="#让车动起来" class="headerlink" title="让车动起来"></a>让车动起来</h6><p>​动起来是动起来了，问题是还是教程的车辆。</p><p>​导入素材的时候用的fbx文件，这个导入存在丢材质的问题，不清楚是为啥，有可能需要单独再下一个Maya来编辑一下。</p><p>​已经下载3DS MAX对素材进行编辑，丢材质问题通过重新导出已经解决，但是仍然面临新的问题，恐怕是UE内的设置问题。</p><p>​对于这个点的详细记述参见下方的知识点记录。</p><blockquote><p>参考资料：</p><p><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/how-to-set-up-vehicles-in-unreal-engine">How to Set up Vehicles in Unreal Engine | Unreal Engine 5.5 Documentation | Epic Developer Community</a></p><p><a href="https://zhuanlan.zhihu.com/p/527689309">UE5-Vehicle车辆载具探索-ChaosVehicle概述 - 知乎</a></p></blockquote><h5 id="知识点记录-1"><a href="#知识点记录-1" class="headerlink" title="知识点记录"></a>知识点记录</h5><h6 id="让车动起来——Chaos载具引擎的简单实用"><a href="#让车动起来——Chaos载具引擎的简单实用" class="headerlink" title="让车动起来——Chaos载具引擎的简单实用"></a>让车动起来——Chaos载具引擎的简单实用</h6><p>​十分幸运的是文档中为载具专门列出了一项，这就是Chaos载具引擎的使用。</p><p>​借助示例项目的Buggy车骨架我们可以简单过一遍把车辆骨骼体制成专门的车辆蓝图并且使它动起来的过程。</p><p>​简单的流程就是：（保证Chaos载具引擎开启）-&gt;|为车辆前后轮分别创建Wheel蓝图-&gt;根据前后轮的情况设定参数（车辆小知识：一般家用车均为前驱车）-&gt;新建Float曲线-&gt;（导入车辆骨骼网格体）-&gt;创建物理资产，为车辆设置碰撞体-&gt;新建动画蓝图，为对应的车辆骨骼网格体设置WheelController（复杂一些的话，教程这里还有提到LookAt节点，但考虑到我们的车子不会面临什么很严峻的地形情况…）-&gt;创建轮式载具的Pawn-&gt;为Pawn绑定车轮，将曲线导入为Torque Curve（这里是一个疑问点，我对车了解不多…）|-&gt;绑定摄像机，Gamemode，操作等-&gt;可以人工操作</p><p>​在竖线之间的便是绑定车辆并使其动起来的全流程，或者按照参考资料2的说法就是工作流。按着教程一步步来是可以较为简单实现的，步骤看似繁多但是跟着做下来的话对整个流程还是较为清楚的。</p><p>​当前节点的问题便是，如何从轿车模型制作出车辆骨骼体。能解决这个问题的话那应该就能完成量产轿车的工作流了。</p><h6 id="关于处理fbx素材"><a href="#关于处理fbx素材" class="headerlink" title="关于处理fbx素材"></a>关于处理fbx素材</h6><p>​使用3DS MAX对FBX文件进行处理。可下载下来的文件基本都是FBX，OBJ格式的文件，并且没有经过骨骼绑定加工而只是纯粹的静态模型。对于这部分模型还需要额外的加工才能将其变成实际可用于导入的素材。</p><p>​参考的博客是这个：<a href="https://blog.csdn.net/m0_61047553/article/details/142516817">UE5 载具 从静态网格体生成骨骼网格体（使用3ds Max）_ue5静态网格体转换骨骼网格体-CSDN博客</a></p><p>​也就是说需要下载部分素材手动将其构建出符合要求的FBX文件再导入虚幻引擎，在实际进行系统搭建时需要能够最大限度复用素材来组合出不同车辆（不然就得堆量干体力活了）。素材的话因为还存在别的免费素材网站倒是不需要特别着急。</p><p>​现在的情况是素材处理成功，导入也成功了。</p><p>​仍然残余问题，用自制素材合成的车辆Pawn也能跑通构造流程而不报错，但是在实际测试时会发生相当鬼畜的情况以至于自制素材并没有办法实际投入使用。这个问题现在正在解决中……</p><p>​根据参考资料来看仍然有可能是模型加工未到位的问题，需要进一步深究。关于模型加工，一旦成功会立刻更新到周报中。</p><p>​疑似骨骼绑定出现问题，UE5和DCC软件是不能分开学的。初步排查，UE5内骨骼绑定存在问题，需要回3DS MAX那边学跟骨骼绑定相关的知识。</p><p>​资料：[Why is my wheeled vehicle flying away?<a href="https://forums.unrealengine.com/t/why-is-my-wheeled-vehicle-flying-away-solved/328365/2">SOLVED] - Development &#x2F; World Creation - Epic Developer Community Forums</a></p><h4 id="W4"><a href="#W4" class="headerlink" title="W4"></a>W4</h4><p>​本周聚焦UE5的相关问题，希望解决的问题包括：</p><ul><li>调研一下库（长期任务，本周比重不是那么大，可以选做）</li><li>把路网和车组装起来看看（碰撞怎么办，物理怎么办）（优先级高）</li><li>人车交互</li><li>多车的不同操作</li><li>车动起来（跑通从DIY骨架开始的整个流程）</li></ul><p>​关于虚幻5的学习，经历了约1个月，有一些碎碎念了。</p><p>​无论是油管还是B站，各种入门向视频讲的相对我目前希望的程度而言是过浅的。只有针对一个具体的案例去学习才可能对这一块有所收获。也就是说这玩意最合适的还得是案例式学习。根据需要实现的功能去查阅文档然后实现这块的功能，这就是UE5较好的一个学习方式了。未来做Demo也是如此，根据需求功能去对点查文档和视频进行学习，然后进行一个实现。</p><h5 id="实践要求-2"><a href="#实践要求-2" class="headerlink" title="实践要求"></a>实践要求</h5><h6 id="让车动起来-1"><a href="#让车动起来-1" class="headerlink" title="让车动起来"></a>让车动起来</h6><p>​困扰了4天的问题因为一个无意的操作而解决了。</p><p>​所有的流程都是跑的通的，从搭建骨架开始的所有流程都是通的。</p><p>​造成这个蛋疼问题的最终原因是物理资产的设置错误，那个物理资产，如果只有轮子图元是开着碰撞的话是跑不通的，会螺旋升天；需要将车身的碰撞也打开才行。<strong>将车身碰撞打开后碰撞就会正常</strong>，其他的所有流程都是跑的通的！</p><p>​至此这个问题迎来完美落幕。车的运动仍然存在不少瑕疵，但是至少它能正常跑起来了。</p><h6 id="车辆与路网的碰撞"><a href="#车辆与路网的碰撞" class="headerlink" title="车辆与路网的碰撞"></a>车辆与路网的碰撞</h6><p>​不是问题的问题，在解决了让车辆落地的问题之后，这个问题自然就解决了。</p><p>​本身，静态网格体默认是开启碰撞的，所以车也就能正常在上面运行了。</p><h6 id="人车交互设计"><a href="#人车交互设计" class="headerlink" title="人车交互设计"></a>人车交互设计</h6><p>​按照学长在聊天记录当中说明的那个意思应该正确是车辆的状态表示。</p><p>​通过不同颜色信息表达车辆所处的不同状态，然后切换状态时切换车所拥有的颜色。</p><p>​举个例子，在接客过程中是红色，在运行过程中是黄色，在下车过程中是绿色。来回切换。至于人的话，其实只要在对应的目标点周围生成一个等待的人的模型就行（或者选中一个人让它处于等待状态？）</p><p>​调研的时候是往互动动画那一块去调研了，只能说稍微走了一些弯路。</p><p>​如果是往这一块走的话，可能需要去查看如何完成一些特效，用简单的特效去标记车辆。</p><h6 id="多车运动"><a href="#多车运动" class="headerlink" title="多车运动"></a>多车运动</h6><p>​重点应该放在这里。</p><p>​让车动起来的步骤的话：</p><p>​让车能在人的操作下动起来-&gt;让车能在AI控制器的控制下动起来-&gt;让车能在指定的路径下动起来-&gt;让车辆能按照交规动起来-&gt;让大量车能在路上按照交规动起来</p><p>​感觉这一块需要一些迭代。</p><p>​UE5具有的AI工具箱是较为复杂的，这一块可能还要花一些时间学。</p><p>​同时因为AI蓝图确实涉及到了大量蓝图编程，这一块也需要花时间继续适应。</p><p>​难道说车和人的AI移动配置上不一样？AI Move To蓝图似乎有限制，它只能移动角色而不能移动载具。需要另外寻找解决方案？</p><p>​目前查阅到的资料中，车辆的自动驾驶有两种方案：基于样条线的移动方案和从0开始搭建一个车辆移动任务的方案（这后者也就是从0开始造轮子，会有些麻烦）。根据社区交流来看可能存在插件能做到车辆自动驾驶这一行为的，但是还需要继续调研一下。</p><p>​MassEntity的资料很少，得多翻墙看看。对于少车辆的高精度移动而言，AI工具箱所提供的功能应该是够用的。</p><blockquote><p>参考资料：</p><p><a href="https://www.bilibili.com/video/BV1dz4y1A7G3/?p=2&spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e3bc0a74b003e86cc67e459d9355420a">1 选择与顺序节点_哔哩哔哩_bilibili</a></p><p>这位的视频对AI工具箱有一个很明确的讲解，讲的是相当全面的</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/artificial-intelligence-in-unreal-engine">虚幻引擎中的人工智能 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p>文档中关于人工智能的模块</p><p>同时可能会用到的MassEntity框架的资料略少，现在还需要找更多资料</p></blockquote><h5 id="知识点记录-2"><a href="#知识点记录-2" class="headerlink" title="知识点记录"></a>知识点记录</h5><h6 id="如何让一辆车简单的动起来（复盘）"><a href="#如何让一辆车简单的动起来（复盘）" class="headerlink" title="如何让一辆车简单的动起来（复盘）"></a>如何让一辆车简单的动起来（复盘）</h6><p>​从车辆网格体开始搭建车的骨骼模型可以参考：</p><p><a href="https://blog.csdn.net/m0_61047553/article/details/142516817">UE5 载具 从静态网格体生成骨骼网格体（使用3ds Max）_ue5静态网格体转换骨骼网格体-CSDN博客</a></p><p>​而从网格模型生成实际可驾驶的车辆则是：</p><p><a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/how-to-set-up-vehicles-in-unreal-engine">如何设置载具 | 虚幻引擎 5.5 文档 | Epic Developer Community</a></p><p>​这两篇即可，踩的最多的坑是物理资产的设置，物理资产是可以管碰撞的。需要具体学学物理资产的作用。另外，静态网格体的碰撞要前往静态网格体本身进行设置。这一块的相关技术可以再找一些教程看看。</p><h6 id="蓝图调试"><a href="#蓝图调试" class="headerlink" title="蓝图调试"></a>蓝图调试</h6><p>​蓝图也可以通过打上断点来进行调试。</p><p>​对于可视化编程，我们可以随时在接点进行数据查看和追踪。这一点可以通过打开函数直接查看。AI工具箱的行为树也支持类似的行为追踪。</p><p>​UE5本身也支持蓝图调试器的使用，可以通过追踪类，查看每个类下拥有的个体的当前值。</p><h6 id="AI初步"><a href="#AI初步" class="headerlink" title="AI初步"></a>AI初步</h6><p>​初步的AI主要聚焦于行为树和黑板，前者规定AI的行为，后者涉及AI判断行为执行的标准。</p><p>​使用AI的流程：创建AI控制器-&gt;将NPC的AI控制器设置为创建好的AI控制器，并设置生成和放置-&gt;AI控制器蓝图，运行行为树同时绑定对应行为树。到这里初期设置完成。</p><p>​基本节点有Selector，Sequencer和Simple Parallel。主要聚焦前两个节点。Selector从左到右执行，只要有一个子节点任务是可以成功执行的就返回。Sequencer是从左往右依次执行所有节点，遇到子节点失败即退出，全部节点成功也会返回。</p><p>​可以添加导航网格体体积标识NPC可以前往的地方（合法坐标？）</p><p>​在Task中设置的黑板键选择器一定要把“可见”勾出来，这样才能做到与黑板的数据交互。</p><p>​关于人和车的AI自动驱动测试，感觉存在相似的地方。要不要使用接口进行解耦？</p><h4 id="W5"><a href="#W5" class="headerlink" title="W5"></a>W5</h4><p>​本周希望完成的任务有：</p><ul><li><strong>车能在AI控制器的驱动下动起来</strong>（最重要）</li><li><strong>设计数据表&#x2F;接口表，车能够按照后端来的数据运动（ID，下一时刻的位置，中间的路线）</strong><ul><li>前后端的数据交互接口，实现多车运动，自己搓一个数据出来跑一次试试。</li><li>数据-&gt;路径-&gt;驱动车跑</li><li>不求完善，但是能跑</li></ul></li><li><strong>OSM文件的数据如何映射到城市模型上</strong>（很重要），<strong>表示数据就行，具体运行细节交给后端</strong></li></ul><p>​同样的，这周任务没有一个轻松的。我不确定是否需要将这些任务延长到两周，看上去确实相当棘手。只能说，尽力而为。</p><h5 id="实践要求-3"><a href="#实践要求-3" class="headerlink" title="实践要求"></a>实践要求</h5><h6 id="让人动起来（AI）"><a href="#让人动起来（AI）" class="headerlink" title="让人动起来（AI）"></a>让人动起来（AI）</h6><p>​也遇到了人不动的问题，最后误打误撞调试对了。</p><p>​目前手动给人设置目标后它可以按照既定目标路径动起来（使用寻路点作为引导物）</p><p>​debug出现的问题是行为树Move To节点中的“可接受半径”参数</p><p>​它的作用是让运行成功的范围，变成以所选坐标为圆心，可接受半径为半径的圆</p><p>​一开始因为把这个参数设的非常大（不理解此参数的含义）导致人无法移动</p><p>​根据测试可知，必须让AIPawn处于导航体积内才可以让它正确实现驱动</p><h6 id="让车动起来（AI）"><a href="#让车动起来（AI）" class="headerlink" title="让车动起来（AI）"></a>让车动起来（AI）</h6><p>​经过测试，车辆确实不适用行为树的原生的Move To逻辑，需要自己重新手写</p><p>​需要学习VehicleMoveComponent及其相关蓝图函数的使用方法，然后自行拼出一个可用的节点方案</p><p>​预期另开一篇博客记录学习到的内容和实现的思路，相信会有点多</p><blockquote><p>参考资料：</p><p><a href="https://blog.csdn.net/qq_34437757/article/details/133029202">UE5 ChaosVehicles载具研究 （连载一）_ue5载具转弯车轮卡顿-CSDN博客</a></p><p>这篇博客介绍了ChaosVehicle的常用节点及其功能，同时对摄像头的变换有启发</p><p><a href="https://www.bilibili.com/video/BV1BP4y1G78z/?spm_id_from=333.337.search-card.all.click&vd_source=e3bc0a74b003e86cc67e459d9355420a">虚幻引擎 - 车辆AI导航（非样条线）教程（全网首个非Character寻路教程）（已上传字幕文件）_哔哩哔哩_bilibili</a></p><p>实现上参考这个视频</p></blockquote><h5 id="知识点记录-3"><a href="#知识点记录-3" class="headerlink" title="知识点记录"></a>知识点记录</h5><h6 id="AI工具箱"><a href="#AI工具箱" class="headerlink" title="AI工具箱"></a>AI工具箱</h6><p>​已另开文章记录，请去博客主页查看。</p><h6 id="UE5中如何控制车辆的运动"><a href="#UE5中如何控制车辆的运动" class="headerlink" title="UE5中如何控制车辆的运动"></a>UE5中如何控制车辆的运动</h6><p>​另开文章记录，请去博客主页查看。</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>UE5</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UE5</tag>
      
      <tag>DCC入门</tag>
      
      <tag>实习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>刷题遇到的公式的集锦</title>
    <link href="/2024/04/06/%E5%9C%A8%E5%88%B7%E9%AB%98%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%84%9F%E8%A7%89%E5%8F%AF%E7%94%A8%E7%9A%84%E5%85%AC%E5%BC%8F/"/>
    <url>/2024/04/06/%E5%9C%A8%E5%88%B7%E9%AB%98%E6%95%B0%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E6%84%9F%E8%A7%89%E5%8F%AF%E7%94%A8%E7%9A%84%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>​这里记录一些刷题时遇到的感觉有用的公式，随手记的，会比较乱</p><p>​有很大可能都是跟三角函数和反三角函数相关的公式，先把一个重要的链接先附在这里方便公式查询：</p><p>​<a href="https://zhuanlan.zhihu.com/p/477761582">正反三角函数嵌套原理 - 知乎 (zhihu.com)</a></p><hr><p>$$<br>\int \frac{1}{1 + sin(x)} dx&#x3D; tan({x \over 2} - {\pi \over 4}) + C &#x3D; tan(x) - sec(x) + C<br>$$</p><p>​这个部分的证明思路，对于第一个连等号：<br>$$<br>\int {1 \over 1 + sin(x)} dx&#x3D; \int {1 \over 1 + cos(x - {\pi \over 2})} dx<br>$$<br>​然后使用下面的姐妹公式就会得到结果</p><p>​对于第二个连等号，上下同乘以 $1 - sin(x)$ :<br>$$<br>\int \frac{1}{1 + sin(x)} dx &#x3D; \int \frac{1 - sin(x)}{cos^2(x)} dx<br>$$<br>​然后拆开减号分别化简即可</p><hr><p>$$<br>\int \frac{1}{1 + cos(x)} dx&#x3D; tan({x \over 2}) + C &#x3D; csc(x) - cot(x) + C<br>$$</p><p>​第一个连等号直接可以采用二倍角展开解，第二个连等号跟上面的思路类似同乘以 $1 - cos(x)$ </p><hr><p>$$<br>tan({arcsin(x) \over 2}) &#x3D; \frac{1 - \sqrt{1 - x^2}}{x}<br>$$</p><p>​这个公式可以由半角公式得到，取正即可：<br>$$<br>tan({x \over 2}) &#x3D; \pm \sqrt{ {1 - cos(x)} \over {1 + cos(x)} }<br>$$</p><hr><p>$$<br>\int tan^2(x) dx &#x3D; tan(x) - x + C<br>$$</p><p>​可能一时间会忘记掉所以补上这个，这个实际是这么推的：<br>$$<br>\int tan^2(x)\ dx &#x3D; \int (sec^2(x) - 1)\ dx &#x3D; tan(x) - x + C<br>$$<br>​也算很常用，可以记忆一下然后直接写</p><hr><p>$$<br>arctan(\sqrt{e^x-1}) + arcsin(e^{- {x \over 2} }) &#x3D; {\pi \over 2}<br>$$</p><p>​很神奇的等式，证明就是求导后等于0，然后代入 x &#x3D; 0 即可</p><hr><p>（可能会继续补充）</p>]]></content>
    
    
    
    <tags>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 MIT 6.S081 Lab4 个人题解</title>
    <link href="/2024/01/05/2021-MIT-6.S081-Lab4/"/>
    <url>/2024/01/05/2021-MIT-6.S081-Lab4/</url>
    
    <content type="html"><![CDATA[<p>​本实验耗时3小时，这次的实验的第一大题是理论部分，同样是如果后面有空再来补（虽说这次的理论确实认认真真做了一下并且查了很多资料，但讲实话我不保证我能全写对）</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h3><p>​这个实验最核心的点在于栈的结构，提示中我觉得最重要的两个提示就是：</p><ul><li><strong>Note that the return address lives at a fixed offset (-8) from the frame pointer of a stackframe, and that the saved frame pointer lives at fixed offset (-16) from the frame pointer.</strong></li><li><strong>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address. You can compute the top and bottom address of the stack page by using <code>PGROUNDDOWN(fp)</code> and <code>PGROUNDUP(fp)</code> ，These number are helpful for <code>backtrace</code> to terminate its loop.</strong></li></ul><p>​怎么理解这两个提示呢？首先，第一个提示提示你偏移是固定的，查看Note可知栈的结构，这里明确的告诉了我们偏移量，所以我们可以通过指针运算取到返回地址和上一个fp的地址；其次，我们的栈<strong>只使用了一页</strong>，这就意味着栈内的地址<strong>一定处于限制这个页的两个地址之间</strong>，所以这也就限制了<strong>fp所在的地址必然也在这两个地址之间</strong>，所以我们就得到了退出循环的条件</p><p>​核心代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    uint64 fp = r_fp();<br>    uint64 top = PGROUNDDOWN(fp); <span class="hljs-comment">// we use minus to allocate stack space, hinting that top is a smaller value</span><br>    uint64 bottom = PGROUNDUP(fp); <span class="hljs-comment">// so the bottom should be bigger value</span><br>    <span class="hljs-keyword">while</span>(fp &gt; top &amp;&amp; fp &lt; bottom)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p\n&quot;</span>, *(uint64*)(fp - <span class="hljs-number">8</span>));<br>        fp = *(uint64*)(fp - <span class="hljs-number">16</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h3><p>​这个实验是分两个部分的，分开讲</p><h4 id="sigalarm"><a href="#sigalarm" class="headerlink" title="sigalarm"></a>sigalarm</h4><p>​我们要求先实现 <code>sigalarm</code> 系统调用，首先先根据提示对 <code>kernel/proc.h</code> 的结构体进行修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// for lab alarm</span><br>  <span class="hljs-type">int</span> need_alarm;              <span class="hljs-comment">// Check if the proc need alarm</span><br>  <span class="hljs-type">int</span> tick;                    <span class="hljs-comment">// Record tick needed</span><br>  uint64 handler_ptr;          <span class="hljs-comment">// Record addr of handler function</span><br>  <span class="hljs-type">int</span> proc_time;               <span class="hljs-comment">// Record ticks that have spent</span><br></code></pre></td></tr></table></figure><p>​注意增加玩新的字段后要修改对应的函数，这里同Lab2，不再赘述</p><p>​然后实现最核心的 <code>sys_sigalarm</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// for lab alarm</span><br>uint64 <span class="hljs-title function_">sys_sigalarm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-type">int</span> xtick;<br>    uint64 handler_addr;<br><br>    <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;xtick) || argaddr(<span class="hljs-number">1</span>, &amp;handler_addr))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span>(xtick || handler_addr)&#123;<br>        p-&gt;need_alarm = <span class="hljs-number">1</span>;<br>        p-&gt;tick = xtick;<br>        p-&gt;handler_ptr = handler_addr;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        p-&gt;need_alarm = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​注意提示说（0,0）要特判，只是赋值字段而已</p><p>​然后提示我们应该修改 <code>kernel/trap.c</code> ，对时钟中断进行更改，这里提示问了一个问题：当RISC-V返回用户空间时什么决定了用户空间继续执行的指令的地址，这个答案显而易见就是pc，所以修改pc就行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>      p-&gt;proc_time++; <span class="hljs-comment">// 其实有可能会溢出，这样写不算很好</span><br>      <span class="hljs-keyword">if</span>(p-&gt;need_alarm &amp;&amp; p-&gt;proc_time &gt;= p-&gt;tick)&#123;<br>          p-&gt;trapframe-&gt;epc = p-&gt;handler_ptr;<br>          p-&gt;proc_time -= p-&gt;tick;<br>      &#125;<br>      yield();<br>  &#125;<br></code></pre></td></tr></table></figure><p>​这之后Test0通过</p><h4 id="sigreturn"><a href="#sigreturn" class="headerlink" title="sigreturn"></a>sigreturn</h4><p>​这里要做的就是正确恢复现场，在极端暴力的情况下直接保存Trapframe就行</p><p>​所以我们做这样的更改：</p><p>​对 <code>kernel/proc.h</code> 新增结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// for return</span><br>  <span class="hljs-type">int</span> is_handling;             <span class="hljs-comment">// Record whether the proc is handling trap</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">st</span>;</span>        <span class="hljs-comment">// Record trapframe before assignment</span><br></code></pre></td></tr></table></figure><p>​注意这里的st字段是一个指针，不能直接赋值，所以要使用 <code>kalloc</code> 函数赋值，具体参考 <code>kernel/proc.c</code> 操作，在分配进程时就可以初始化这个字段，然后在进程释放时注意释放掉这块内存</p><p>​然后更新判断条件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span>(which_dev == <span class="hljs-number">2</span>)&#123;<br>      p-&gt;proc_time++;<br>      <span class="hljs-keyword">if</span>(p-&gt;need_alarm &amp;&amp; p-&gt;proc_time &gt;= p-&gt;tick &amp;&amp; !p-&gt;is_handling)&#123;<br>          memmove(p-&gt;st, p-&gt;trapframe, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe)); <span class="hljs-comment">// 直接这样比较快</span><br>          p-&gt;is_handling = <span class="hljs-number">1</span>;<br>          p-&gt;trapframe-&gt;epc = p-&gt;handler_ptr;<br>          p-&gt;proc_time -= p-&gt;tick;<br>      &#125;<br>      yield();<br>  &#125;<br></code></pre></td></tr></table></figure><p>​然后实现 <code>sigreturn</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">sys_sigreturn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br>    memmove(p-&gt;trapframe, p-&gt;st, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> trapframe));<br>    p-&gt;is_handling = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 应该是p-&gt;trapframe-&gt;a0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>​注意这里的返回值，虽说在本实验中这个0不会发生什么大事但其实是错的，系统调用并不可以覆盖掉原来的返回值，所以需要返回原来的返回值（也就是根据调用规范保存在a0中的那个值）</p><p>​就像题目一开始说的，实现到最后其实代码量是不大的，关键是理清楚整个Trap机制的运行逻辑</p><p>​保存整个Trapframe或许是不必要的，其实只要保存当中的几个寄存器就行，但是笔者并不清楚怎么保存，可以之后再来补</p><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>（待补充）</p><h2 id="通关证明"><a href="#通关证明" class="headerlink" title="通关证明"></a>通关证明</h2><p><img src="/img/Posts/2021-MIT-6.S081/2021-MIT-6.S081-Lab4.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSDIY</category>
      
      <category>操作系统</category>
      
      <category>2021-MIT-6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSDIY</tag>
      
      <tag>操作系统</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 MIT 6.S081 Lab3 个人题解</title>
    <link href="/2023/12/30/2021-MIT-6.S081-Lab3/"/>
    <url>/2023/12/30/2021-MIT-6.S081-Lab3/</url>
    
    <content type="html"><![CDATA[<p>​这个实验总耗时约5小时，但是讲实话，第一次接触页表的话这将会是一个非常绕的概念</p><p>​这个题解只有实验部分，这个实验是有理论部分的，但是奈何我真的菜，所以不会:(</p><p>​所以就还是等什么时候理解了再回来补吧，先预留一个</p><h2 id="实验部分"><a href="#实验部分" class="headerlink" title="实验部分"></a>实验部分</h2><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>​首先先明白一点就是这个实验对第一次接触页表的初学者而言确实比较难，原因就是页表的映射概念确实非常绕。在做这个实验之前务必理解页表映射的原理以及能够读懂本实验相关代码的意义。</p><h3 id="ugetpid"><a href="#ugetpid" class="headerlink" title="ugetpid"></a>ugetpid</h3><p>​题目要求将一页只读页映射到虚拟地址USYSCALL上，并且对其进行初始化</p><p>​根据提示我们将前往 <code>kernel/proc.c</code> 中更改 <code>proc_pagetable</code> 及其他相关函数， 并且提示使用 <code>mappage</code> 函数以及更改 <code>freeproc</code> 和 <code>allocproc</code> 函数</p><p>​对于 <code>proc_pagetable</code> 函数，它为进程生成页表，对于这部分的更改可以仿照这个函数中其他的部分进行，是可以模仿的。要做的就是映射一页去往对应结构。因此这里我们也需要更改 <code>proc.h</code> 以添加新的结构，可以参考 <code>trapframe</code> 这个属性</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// proc.h</span><br><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br><br>  <span class="hljs-comment">// for usyscall: add property here</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">usyscall</span>* <span class="hljs-title">usyscall</span>;</span>   <span class="hljs-comment">//  Store usyscall info</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// proc.c</span><br><span class="hljs-comment">// Create a user page table for a given process,</span><br><span class="hljs-comment">// with no user memory, but with trampoline pages.</span><br><span class="hljs-type">pagetable_t</span><br><span class="hljs-title function_">proc_pagetable</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-type">pagetable_t</span> pagetable;<br><br>  <span class="hljs-comment">// An empty page table.</span><br>  pagetable = uvmcreate();<br>  <span class="hljs-keyword">if</span>(pagetable == <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// map the trampoline code (for system call return)</span><br>  <span class="hljs-comment">// at the highest user virtual address.</span><br>  <span class="hljs-comment">// only the supervisor uses it, on the way</span><br>  <span class="hljs-comment">// to/from user space, so not PTE_U.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAMPOLINE, PGSIZE,<br>              (uint64)trampoline, PTE_R | PTE_X) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// map the trapframe just below TRAMPOLINE, for trampoline.S.</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, TRAPFRAME, PGSIZE,<br>              (uint64)(p-&gt;trapframe), PTE_R | PTE_W) &lt; <span class="hljs-number">0</span>)&#123;<br>    uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    uvmfree(pagetable, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// For speed up getpid:</span><br>  <span class="hljs-comment">// map one read-only page to USYSCALL</span><br>  <span class="hljs-comment">// store a struct usyscall and initialize it with pid of the current process</span><br>  <span class="hljs-keyword">if</span>(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_U | PTE_R) &lt; <span class="hljs-number">0</span>)&#123;<br>      uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>      uvmfree(pagetable, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> pagetable;<br>&#125;<br></code></pre></td></tr></table></figure><p>​根据题目提示不难分析出需要选择什么权限，注意这里的错误处理，需要先解除映射然后再进行释放操作</p><p>​接下来更改对应的其他函数，这里需要注意有的需要修改的函数可能并没有在提示中出现，需要自己察觉。做这个实验被坑的时间首先出现在这里</p><p>​其他要修改的函数包括 <code>allocproc</code> , <code>freeproc</code> , 和 <code>proc_freepagetable</code> , 全部修改完就可以通过第一问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// free a proc structure and the data hanging from it,</span><br><span class="hljs-comment">// including user pages.</span><br><span class="hljs-comment">// p-&gt;lock must be held.</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">freeproc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> proc *p)</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(p-&gt;trapframe)<br>    kfree((<span class="hljs-type">void</span>*)p-&gt;trapframe);<br>  p-&gt;trapframe = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;usyscall) <span class="hljs-comment">// 仿照 trapframe 即可，注意这个kfree</span><br>      kfree((<span class="hljs-type">void</span>*)p-&gt;usyscall);<br>  p-&gt;usyscall = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable)<br>    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);<br>  p-&gt;pagetable = <span class="hljs-number">0</span>;<br>  p-&gt;sz = <span class="hljs-number">0</span>;<br>  p-&gt;pid = <span class="hljs-number">0</span>;<br>  p-&gt;parent = <span class="hljs-number">0</span>;<br>  p-&gt;name[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>  p-&gt;chan = <span class="hljs-number">0</span>;<br>  p-&gt;killed = <span class="hljs-number">0</span>;<br>  p-&gt;xstate = <span class="hljs-number">0</span>;<br>  p-&gt;state = UNUSED;<br>&#125;<br><br><span class="hljs-comment">// Free a process&#x27;s page table, and free the</span><br><span class="hljs-comment">// physical memory it refers to.</span><br><span class="hljs-type">void</span><br><span class="hljs-title function_">proc_freepagetable</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable, uint64 sz)</span><br>&#123;<br>  uvmunmap(pagetable, TRAMPOLINE, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmunmap(pagetable, TRAPFRAME, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>  uvmunmap(pagetable, USYSCALL, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 这个函数不在提示范围之内，这里要改，解除映射，否则将无法释放页表会报panic</span><br>  uvmfree(pagetable, sz);<br>&#125;<br><br><span class="hljs-comment">// Look in the process table for an UNUSED proc.</span><br><span class="hljs-comment">// If found, initialize state required to run in the kernel,</span><br><span class="hljs-comment">// and return with p-&gt;lock held.</span><br><span class="hljs-comment">// If there are no free procs, or a memory allocation fails, return 0.</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> proc*<br><span class="hljs-title function_">allocproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br><br>  <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;<br>    acquire(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">if</span>(p-&gt;state == UNUSED) &#123;<br>      <span class="hljs-keyword">goto</span> found;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      release(&amp;p-&gt;lock);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>found:<br>  p-&gt;pid = allocpid();<br>  p-&gt;state = USED;<br><br>  <span class="hljs-comment">// Allocate a trapframe page.</span><br>  <span class="hljs-keyword">if</span>((p-&gt;trapframe = (<span class="hljs-keyword">struct</span> trapframe *)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Allocate a usyscall page. 仿照 trapframe 分配一页物理页表</span><br>  <span class="hljs-keyword">if</span>((p-&gt;usyscall = (<span class="hljs-keyword">struct</span> usyscall*)kalloc()) == <span class="hljs-number">0</span>)&#123;<br>      freeproc(p);<br>      release(&amp;p-&gt;lock);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// An empty user page table.</span><br>  p-&gt;pagetable = proc_pagetable(p); <span class="hljs-comment">// 创建页表，只读会在这里得到映射</span><br>  <span class="hljs-keyword">if</span>(p-&gt;pagetable == <span class="hljs-number">0</span>)&#123;<br>    freeproc(p);<br>    release(&amp;p-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Set up new context to start executing at forkret,</span><br>  <span class="hljs-comment">// which returns to user space.</span><br>  <span class="hljs-built_in">memset</span>(&amp;p-&gt;context, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(p-&gt;context));<br>  p-&gt;context.ra = (uint64)forkret;<br>  p-&gt;context.sp = p-&gt;kstack + PGSIZE;<br>  p-&gt;usyscall-&gt;pid = p-&gt;pid; <span class="hljs-comment">// 分配完记得初始化就行</span><br><br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="vmprint"><a href="#vmprint" class="headerlink" title="vmprint"></a>vmprint</h3><p>​根据题意在 <code>exec</code> 函数那里进行修改后开始本题</p><p>​注意在 <code>kernel/defs.h</code> 中加入我们的函数原型，函数实现在 <code>kernel/vm.c</code> 中</p><p>​提示要求参考 <code>freewalk</code> 函数，确实因为基本也是类似那样子的递归调用</p><p>​需要注意的有：</p><ul><li>如何处理缩进，注意可以使用 <code>string.c</code> 的函数以及指针运算实现</li><li>不妨把这个函数拆成两个，一个入口函数一个递归调用函数，入口函数可以处理第一行的情况</li><li><code>riscv.h</code> 中有很多有用的宏</li></ul><p>​于是就可以得到这样的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// vm.c</span><br><span class="hljs-type">char</span> indent[<span class="hljs-number">60</span>] = <span class="hljs-string">&quot; ..&quot;</span>; <span class="hljs-comment">// 用于处理缩进，注意第一个字符是空格</span><br><br><span class="hljs-type">void</span> _vmprint(<span class="hljs-type">pagetable_t</span> pagetable)&#123;<br>    <span class="hljs-comment">// there are 2^9 = 512 PTEs in a page table.</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">512</span>; i++)&#123;<br>        <span class="hljs-type">pte_t</span> pte = pagetable[i];<br>        <span class="hljs-keyword">if</span>((pte &amp; PTE_V))&#123; <span class="hljs-comment">// valid pte</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s%d: pte %p pa %p\n&quot;</span>, indent, i, pte, PTE2PA(pte));<br>            <span class="hljs-keyword">if</span>((pte &amp; (PTE_R|PTE_W|PTE_X)) == <span class="hljs-number">0</span>)&#123; <span class="hljs-comment">// category</span><br>                <span class="hljs-comment">// this PTE points to a lower-level page table.</span><br>                uint64 child = PTE2PA(pte);<br>                safestrcpy(indent + <span class="hljs-built_in">strlen</span>(indent), <span class="hljs-string">&quot; ..&quot;</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">// 试完是这样</span><br>                _vmprint((<span class="hljs-type">pagetable_t</span>)child);<br>                safestrcpy(indent + <span class="hljs-built_in">strlen</span>(indent) - <span class="hljs-number">3</span>, <span class="hljs-string">&quot;\0&quot;</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">// 试完是这样</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">vmprint</span><span class="hljs-params">(<span class="hljs-type">pagetable_t</span> pagetable)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;page table %p\n&quot;</span>, pagetable);<br>    _vmprint(pagetable);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="pgaccess"><a href="#pgaccess" class="headerlink" title="pgaccess"></a>pgaccess</h3><p>​这是一道<font color="red">HARD</font>问题，但并不是想象中那么难</p><p>​可以看看它的测试程序，首先先执行了一次pgaccess，然后对buffer中的某3页进行修改后再使用pgaccess测试bitset的情况</p><p>​关于PTE_A的设置，这个位会在被访问后由系统自动设置，所以我们不需要管这个位的设置，只需要考虑这个位如何被识别就行了</p><p>​首先我们先去 <code>kernel/riscv.h</code> 中定义宏，题目要求我们定义出 <code>PTE_A</code> 宏，根据RISC-V调用规范不难算出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//riscv.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTE_A (1L &lt;&lt; 6)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CLEAR_PTE_A(pte)  ((pte) &amp; (~PTE_A))</span><br></code></pre></td></tr></table></figure><p>​根据题目提示需要消除访问位，所以设置上面的 <code>CLEAR_PTE_A</code> 宏</p><p>​根据题目此题需要用到 <code>walk</code> 函数，我们直接在 <code>kernel/defs.h</code> 中将这个函数的原型填上去，然后再去设计实际的 <code>sys_pgaccess</code> 函数</p><p>​首先理解 <code>walk</code> 函数做了什么，它拿到页表物理地址和待查询虚拟地址，根据映射原理拿到页表中对应此虚拟地址的页表项的地址。我们要的就是这个页表项的地址，因为可以对实际的页表项进行修改</p><p>​注意使用专门的函数获得参数，就像Lab2一样，选用32位的bitset就足够了</p><p>​至此完成本Lab的实验部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// sysproc.c</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">sys_pgaccess</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">// lab pgtbl: your code here.</span><br>  uint64 va, buf_addr;<br>  <span class="hljs-type">pte_t</span>* pte;<br>  <span class="hljs-type">int</span> npages, i;<br>  <span class="hljs-type">int</span> <span class="hljs-built_in">bitset</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;va) &lt; <span class="hljs-number">0</span> || argint(<span class="hljs-number">1</span>, &amp;npages) &lt; <span class="hljs-number">0</span> || argaddr(<span class="hljs-number">2</span>, &amp;buf_addr) &lt; <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  npages = npages &gt; <span class="hljs-number">32</span>? <span class="hljs-number">32</span>: npages; <span class="hljs-comment">// set upper limit</span><br><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; npages; i++, va += PGSIZE)&#123; <span class="hljs-comment">// 这个循环是关键</span><br>      pte = walk(p-&gt;pagetable, va, <span class="hljs-number">0</span>);<br>      <span class="hljs-keyword">if</span>(*pte &amp; PTE_A)&#123; <span class="hljs-comment">// 确定有PTE_A项后要消除</span><br>          <span class="hljs-built_in">bitset</span> ^= (<span class="hljs-number">1L</span> &lt;&lt; i);<br>          *pte = CLEAR_PTE_A(*pte);<br>      &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, buf_addr, (<span class="hljs-type">char</span>*)(&amp;<span class="hljs-built_in">bitset</span>), <span class="hljs-keyword">sizeof</span> <span class="hljs-built_in">bitset</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 根据提示使用copyout函数返回结果</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h2><p>​（待补充）</p><h3 id="过关证明"><a href="#过关证明" class="headerlink" title="过关证明"></a>过关证明</h3><p><img src="/img/Posts/2021-MIT-6.S081/2021-MIT-6.S081-Lab3.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSDIY</category>
      
      <category>操作系统</category>
      
      <category>2021-MIT-6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSDIY</tag>
      
      <tag>操作系统</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 MIT 6.S081 Lab2 个人题解</title>
    <link href="/2023/12/29/2021-MIT-6.S081-Lab2/"/>
    <url>/2023/12/29/2021-MIT-6.S081-Lab2/</url>
    
    <content type="html"><![CDATA[<p>总耗时5小时，但是感觉有写出UB所以仅供参考。会继续完善一下，先贴出解法。</p><h3 id="General"><a href="#General" class="headerlink" title="General"></a>General</h3><p>​在两个题目中都存在以下的操作，需要遵守，在Trace题目中的Hint中已经给出了详细的提示：</p><ul><li>对UPROGS的更改</li><li>提示中提到的部分有：<ul><li>在 <code>user/user.h</code> 中对函数原型进行声明</li><li>在 <code>user/usys.pl</code> 中添加对应的入口</li><li>在 <code>kernel/syscall.h</code> 中添加对应的系统调用号</li></ul></li><li>提示中没提到的还有：<ul><li>对 <code>kernel/syscall.c</code> 中的extern函数群进行更改</li><li>对 <code>kernel/syscall.c</code> 中的系统调用号和函数的映射表进行修改</li></ul></li></ul><p>​在接下来的题解中不涉及对以上部分的更改，以下更改只涉及每个题目专有的部分</p><h3 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h3><p>​根据格式在 <code>kernel/sysproc.c</code> 中实现 <code>sys_trace</code> 函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">sys_trace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-type">int</span> mask;<br><br>    <span class="hljs-keyword">if</span>(argint(<span class="hljs-number">0</span>, &amp;mask) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    myproc()-&gt;tmask = mask;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​由提示可知可以对 <code>proc</code> 结构进行适当修改，所以对 <code>kernel/proc.h</code> 修改一下（不过这里貌似会UB）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Per-process state</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> <span class="hljs-title">lock</span>;</span><br><br>  <span class="hljs-comment">// p-&gt;lock must be held when using these:</span><br>  <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">procstate</span> <span class="hljs-title">state</span>;</span>        <span class="hljs-comment">// Process state</span><br>  <span class="hljs-type">void</span> *chan;                  <span class="hljs-comment">// If non-zero, sleeping on chan</span><br>  <span class="hljs-type">int</span> killed;                  <span class="hljs-comment">// If non-zero, have been killed</span><br>  <span class="hljs-type">int</span> xstate;                  <span class="hljs-comment">// Exit status to be returned to parent&#x27;s wait</span><br>  <span class="hljs-type">int</span> pid;                     <span class="hljs-comment">// Process ID</span><br><br>  <span class="hljs-comment">// wait_lock must be held when using this:</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">parent</span>;</span>         <span class="hljs-comment">// Parent process</span><br><br>  <span class="hljs-comment">// these are private to the process, so p-&gt;lock need not be held.</span><br>  uint64 kstack;               <span class="hljs-comment">// Virtual address of kernel stack</span><br>  uint64 sz;                   <span class="hljs-comment">// Size of process memory (bytes)</span><br>  <span class="hljs-type">pagetable_t</span> pagetable;       <span class="hljs-comment">// User page table</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">trapframe</span> *<span class="hljs-title">trapframe</span>;</span> <span class="hljs-comment">// data page for trampoline.S</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">context</span> <span class="hljs-title">context</span>;</span>      <span class="hljs-comment">// swtch() here to run process</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span> *<span class="hljs-title">ofile</span>[<span class="hljs-title">NOFILE</span>];</span>  <span class="hljs-comment">// Open files</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span> *<span class="hljs-title">cwd</span>;</span>           <span class="hljs-comment">// Current directory</span><br>  <span class="hljs-type">char</span> name[<span class="hljs-number">16</span>];               <span class="hljs-comment">// Process name (debugging)</span><br><br>  <span class="hljs-comment">// added to implement trace call</span><br>  <span class="hljs-type">int</span> tmask;                   <span class="hljs-comment">// Record info for trace call 这一行是新加的</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>​根据提示更改 <code>fork()</code> 以让子进程继承父进程的mask：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// Create a new process, copying the parent.</span><br><span class="hljs-comment">// Sets up child kernel stack to return as if from fork() system call.</span><br><span class="hljs-type">int</span><br><span class="hljs-title function_">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> i, pid;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">np</span>;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  <span class="hljs-comment">// Allocate process.</span><br>  <span class="hljs-keyword">if</span>((np = allocproc()) == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Copy user memory from parent to child.</span><br>  <span class="hljs-keyword">if</span>(uvmcopy(p-&gt;pagetable, np-&gt;pagetable, p-&gt;sz) &lt; <span class="hljs-number">0</span>)&#123;<br>    freeproc(np);<br>    release(&amp;np-&gt;lock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  np-&gt;sz = p-&gt;sz;<br><br>  <span class="hljs-comment">// copy saved user registers.</span><br>  *(np-&gt;trapframe) = *(p-&gt;trapframe);<br><br>  <span class="hljs-comment">// Cause fork to return 0 in the child.</span><br>  np-&gt;trapframe-&gt;a0 = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">// For trace: copy tmask to the child. 这一行是新增的</span><br>  np-&gt;tmask = p-&gt;tmask;<br><br>  <span class="hljs-comment">// increment reference counts on open file descriptors.</span><br>  <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NOFILE; i++)<br>    <span class="hljs-keyword">if</span>(p-&gt;ofile[i])<br>      np-&gt;ofile[i] = filedup(p-&gt;ofile[i]);<br>  np-&gt;cwd = idup(p-&gt;cwd);<br><br>  safestrcpy(np-&gt;name, p-&gt;name, <span class="hljs-keyword">sizeof</span>(p-&gt;name));<br><br>  pid = np-&gt;pid;<br><br>  release(&amp;np-&gt;lock);<br><br>  acquire(&amp;wait_lock);<br>  np-&gt;parent = p;<br>  release(&amp;wait_lock);<br><br>  acquire(&amp;np-&gt;lock);<br>  np-&gt;state = RUNNABLE;<br>  release(&amp;np-&gt;lock);<br><br>  <span class="hljs-keyword">return</span> pid;<br>&#125;<br></code></pre></td></tr></table></figure><p>​最后是对 <code>syscall()</code> 进行更改，根据提示在 <code>syscall()</code> 上更改以输出相应内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span><br><span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-type">int</span> num;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span> =</span> myproc();<br><br>  num = p-&gt;trapframe-&gt;a7;<br>  <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;<br>    p-&gt;trapframe-&gt;a0 = syscalls[num]();<br>    <span class="hljs-comment">// added for trace call 这个条件判断是新增的</span><br>    <span class="hljs-keyword">if</span>(p-&gt;tmask &amp; (<span class="hljs-number">1</span> &lt;&lt; num))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscall_names[num], p-&gt;trapframe-&gt;a0);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %s: unknown sys call %d\n&quot;</span>,<br>            p-&gt;pid, p-&gt;name, num);<br>    p-&gt;trapframe-&gt;a0 = <span class="hljs-number">-1</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h3><p>​在执行General部分的步骤后还需要做的有：</p><ul><li>实现 <code>sys_sysinfo()</code> 函数</li><li>实现 <code>getfreemem()</code> 函数</li><li>实现 <code>getnproc()</code> 函数</li></ul><p>​后面两个函数是根据 <code>sysinfo</code> 结构中对应部分命名的，注意这两个函数在实现之后需要将他们的函数原型加入 <code>kernel/defs.h</code> 文件中，否则将无法使用</p><h4 id="sys-sysinfo"><a href="#sys-sysinfo" class="headerlink" title="sys_sysinfo"></a>sys_sysinfo</h4><p>​这个函数需要弄明白 <code>copyout</code> 函数的用法，需要仔细模仿提示中给出的用法</p><p>​注意在使用这个结构体之前要先include对应的头文件，即 <code>sysinfo.h</code> </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">sys_sysinfo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    uint64 addr;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span>* <span class="hljs-title">p</span> =</span> myproc();<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sysinfo</span> <span class="hljs-title">info</span>;</span><br><br>    <span class="hljs-keyword">if</span>(argaddr(<span class="hljs-number">0</span>, &amp;addr) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>    info.nproc = getnproc();<br>    info.freemem = getfreemem();<br><br>    <span class="hljs-keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="hljs-type">char</span> *)&amp;info, <span class="hljs-keyword">sizeof</span>(info)) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getfreemem"><a href="#getfreemem" class="headerlink" title="getfreemem"></a>getfreemem</h4><p>​首先要去到 <code>kernel/kalloc.c</code> 中，它的写法要模仿这个文件中的 <code>kalloc</code> 函数写</p><p>​这里的知识点涉及分页存储，实际上这里的 freelist 结构相当于是目前仍然可用内存页构成的链表，而PGSIZE常量则代表了一页的大小。初次做可能会不知所以然但是因为笔者做过类JOS实验所以能理解</p><p>​所以遍历链表即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">getfreemem</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    uint64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">run</span> *<span class="hljs-title">r</span>;</span><br><br>    acquire(&amp;kmem.lock);<br>    r = kmem.freelist;<br>    <span class="hljs-keyword">while</span>(r)&#123;<br>        res += PGSIZE;<br>        r = r-&gt;next;<br>    &#125;<br>    release(&amp;kmem.lock);<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="getnproc"><a href="#getnproc" class="headerlink" title="getnproc"></a>getnproc</h4><p>​首先要去到 <code>kernel/proc.c</code> 中，这个函数写法仿照 <code>procdump</code> 函数</p><p>​可以直接照着 <code>procdump</code> 函数改造就行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">uint64 <span class="hljs-title function_">getnproc</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">proc</span> *<span class="hljs-title">p</span>;</span><br>    uint64 count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;<br>        <span class="hljs-keyword">if</span>(p-&gt;state != UNUSED)<br>            count++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="过关证明"><a href="#过关证明" class="headerlink" title="过关证明"></a>过关证明</h3><p><img src="/img/Posts/2021-MIT-6.S081/2021-MIT-6.S081-Lab2.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSDIY</category>
      
      <category>操作系统</category>
      
      <category>2021-MIT-6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSDIY</tag>
      
      <tag>操作系统</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2021 MIT 6.S081 Lab1 个人题解</title>
    <link href="/2023/12/28/2021-MIT-6.S081-Lab1/"/>
    <url>/2023/12/28/2021-MIT-6.S081-Lab1/</url>
    
    <content type="html"><![CDATA[<p>总耗时13小时，先贴上代码，后面再来补充。</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by YCX on 2023/12/27.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: sleep time\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    sleep(atoi(argv[<span class="hljs-number">1</span>]));<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="ping-pong"><a href="#ping-pong" class="headerlink" title="ping-pong"></a>ping-pong</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by YCX on 2023/12/27.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Usage: pingpong\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br><br>    <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-type">int</span> pid = getpid();<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">8</span>);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d: received ping\n&quot;</span>, pid);<br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;pong&quot;</span>, <span class="hljs-number">4</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-type">int</span> pid = getpid();<br>        write(p[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;ping&quot;</span>, <span class="hljs-number">4</span>);<br>        close(p[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">8</span>];<br>        read(p[<span class="hljs-number">0</span>], buf, <span class="hljs-number">8</span>);<br>        close(p[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;%d: received pong\n&quot;</span>, pid);<br>    &#125;<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h3><p>这个是卡了最久的，因为第一次写并发，不是很理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by YCX on 2023/12/27.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL (void*)0</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">sieve</span><span class="hljs-params">(<span class="hljs-type">int</span> read_fd)</span>&#123;<br>    <span class="hljs-type">int</span> prime, n;<br>    <span class="hljs-type">int</span> has_neighbor = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;;<br><br>    read(read_fd, &amp;prime, <span class="hljs-number">4</span>);<br>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;prime %d\n&quot;</span>, prime);<br><br>    <span class="hljs-keyword">while</span>(read(read_fd, &amp;n, <span class="hljs-number">4</span>) != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(n % prime)&#123;<br>            <span class="hljs-keyword">if</span>(!has_neighbor)&#123;<br>                has_neighbor = <span class="hljs-number">1</span>;<br>                pipe(p);<br>                <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>                    close(p[<span class="hljs-number">1</span>]);<br>                    sieve(p[<span class="hljs-number">0</span>]);<br>                &#125;<br>                <span class="hljs-keyword">else</span>&#123;<br>                    close(p[<span class="hljs-number">0</span>]);<br>                &#125;<br>            &#125;<br>            write(p[<span class="hljs-number">1</span>], &amp;n, <span class="hljs-number">4</span>);<br>        &#125;<br>    &#125;<br>    close(p[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">if</span>(has_neighbor)<br>        wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">gen_num</span><span class="hljs-params">(<span class="hljs-type">int</span> write_fd, <span class="hljs-type">int</span> max_num)</span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= max_num; i++)&#123;<br>        write(write_fd, &amp;i, <span class="hljs-number">4</span>);<br>    &#125;<br>    close(write_fd);<br>    wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;<br>    <span class="hljs-type">int</span> max_num = <span class="hljs-number">35</span>;<br><br>    <span class="hljs-type">int</span> p[<span class="hljs-number">2</span>];<br>    pipe(p);<br>    <span class="hljs-keyword">if</span>(fork() != <span class="hljs-number">0</span>)&#123;<br>        close(p[<span class="hljs-number">0</span>]);<br>        gen_num(p[<span class="hljs-number">1</span>], max_num);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        close(p[<span class="hljs-number">1</span>]);<br>        sieve(p[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>需要参考ls程序写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by YCX on 2023/12/28.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/fs.h&quot;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">has_same_name</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span>&#123;<br>    <span class="hljs-type">char</span> *p;<br><br>    <span class="hljs-keyword">for</span>(p=path+<span class="hljs-built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="hljs-string">&#x27;/&#x27;</span>; p--);<br>    p++;<br><br>    <span class="hljs-keyword">return</span> !<span class="hljs-built_in">strcmp</span>(p, target);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">char</span> *path, <span class="hljs-type">char</span> *target)</span>&#123;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>], *p;<br>    <span class="hljs-type">int</span> fd;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dirent</span> <span class="hljs-title">de</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stat</span> <span class="hljs-title">st</span>;</span><br><br>    <span class="hljs-keyword">if</span>((fd = open(path, <span class="hljs-number">0</span>)) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot open %s\n&quot;</span>, path);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(fstat(fd, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, path);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">switch</span>(st.type)&#123;<br>        <span class="hljs-keyword">case</span> T_FILE:<br>            <span class="hljs-keyword">if</span>(has_same_name(path, target))<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, path);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> T_DIR:<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strlen</span>(path) + <span class="hljs-number">1</span> + DIRSIZ + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">sizeof</span> buf)&#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: path too long\n&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-built_in">strcpy</span>(buf, path);<br>            p = buf+<span class="hljs-built_in">strlen</span>(buf);<br>            *p++ = <span class="hljs-string">&#x27;/&#x27;</span>;<br>            <span class="hljs-keyword">while</span>(read(fd, &amp;de, <span class="hljs-keyword">sizeof</span>(de)) == <span class="hljs-keyword">sizeof</span>(de))&#123;<br>                <span class="hljs-keyword">if</span>(de.inum == <span class="hljs-number">0</span> || !<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;..&quot;</span>, de.name) || !<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;.&quot;</span>, de.name))<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-built_in">strcpy</span>(p, de.name);<br>                <span class="hljs-keyword">if</span>(stat(buf, &amp;st) &lt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;find: cannot stat %s\n&quot;</span>, buf);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                find(buf, target);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    close(fd);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-built_in">fprintf</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Usage: find work_path filename\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-type">char</span>* start_path = argv[<span class="hljs-number">1</span>];<br>    <span class="hljs-type">char</span>* target = argv[<span class="hljs-number">2</span>];<br>    find(start_path, target);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><p>这个程序需要参考Unix的xargs程序理解</p><p>如果能理解懂意思就可以写</p><p>问题是指针的应用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by YCX on 2023/12/28.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/stat.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;user/user.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;kernel/param.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL (void*)0</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span>&#123;<br><br>    <span class="hljs-type">char</span> *argvs[MAXARG];<br>    <span class="hljs-type">int</span> i, index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; argc; i++)&#123;<br>        argvs[index++] = argv[i];<br>    &#125;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">512</span>];<br>    argvs[index] = buf;<br><br>    <span class="hljs-type">char</span> *p = buf;<br>    <span class="hljs-keyword">while</span>(read(<span class="hljs-number">0</span>, p, <span class="hljs-number">1</span>))&#123;<br>        <span class="hljs-keyword">if</span>(*p == <span class="hljs-string">&#x27;\n&#x27;</span>)&#123;<br>            *p = <span class="hljs-number">0</span>;<br>            p = buf;<br>            <span class="hljs-keyword">if</span>(fork() == <span class="hljs-number">0</span>)&#123;<br>                exec(argv[<span class="hljs-number">1</span>], argvs);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            p++;<br>    &#125;<br>    wait(<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通关证明"><a href="#通关证明" class="headerlink" title="通关证明"></a>通关证明</h3><p><img src="/img/Posts/2021-MIT-6.S081/2021-MIT-6.S081-Lab1.png"></p>]]></content>
    
    
    <categories>
      
      <category>CSDIY</category>
      
      <category>操作系统</category>
      
      <category>2021-MIT-6.S081</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSDIY</tag>
      
      <tag>操作系统</tag>
      
      <tag>心得</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
